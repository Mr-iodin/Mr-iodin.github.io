# 数据结构——第一章 概论

### 1.1 代码书写规范

**[例]**	设将n(n>1)个整数存放到一维数组R中，设计一个算法，将R中的序列循环左移P(0<P<n)个位置，即将R中的数据由{X<sub>0</sub>,X<sub>1</sub>,X<sub>2</sub>,...,X<sub>n-1</sub>}变化为{X<sub>p</sub>,X<sub>p+1</sub>,X<sub>p+2</sub>,...,X<sub>n-1</sub>,X<sub>0</sub>,X<sub>1</sub>,X<sub>2</sub>,...,X<sub>p-1</sub>}。要求：写出本题的算法描述。

```c
void Reverse(int R[],int l,int r)
{
  int i,j;
  int temp;
  for(i=l,j=r;i<j;i++,j--)
  {
    temp=R[i];
    R[i]=R[j];
    R[j]=temp;
  }
}

void RCR(int R[],int n,int p)
{
  if(p<0||p>=n)
    cout<<"ERROR!"<<endl;
  else{
    Reverse(R,0,p-1);
    Reverse(R,p,n-1);
    Reverse(R,0,n-1);
  }
}
```

##### 1.函数的接口：

假设上述函数是一台机器，可以用来把原材料加工成材料，那么接口就可以理解为**原材料的入口**或者**成品的出口**。换而言之，可以把接口理解为用户与函数打交道的地方，通过接口，用户输入自己的数据，得到想要的结果。

##### 2.数据类型：

考研中涉及整数的问题，没有特别要求就用`int`；涉及小数问题，没有特别要求就用`float`。

##### 3.结构型：

​	结构体是系统提供给程序员制作新的数据类型的一种机制。即可以用系统已有的不同的基本数据类型或用户自定义的结构型，组合成用户需要的复杂的数据结构。

```c
typedef struct
{
  int a;
  int b;
  float c;
}TypeA;
```

由上面这一结构体，可以通过`TypeA a`定义一个新的类型变量。而`a.a`、`a.b`、`a.c`分别对应于结构体第一、第二、第三个元素的值。同理，也可以构建一个新的类型数组`TypeA a[3]`,对应元素可以由`a[0].a`、`a[0].b`、`a[1].c`...来表示。

##### 4.指针型：

​	指针型变量里装的是变量的地址，可以通过它找到这个变量的存储位置。

​	比如，若a是一个指针变量，且它已经指向了一个变量b，则a中存放变量b所在的地址。 `*a`就是**取变量b的内容**(x=*a等价于x=b),

`&b`就是**取变量b的地址**,`a=&b`表示吧变量b的地址存放于a中，也就是使指针a指向b。

##### 5.结点构造：

* 链表结点的定义

<img src="https://i.loli.net/2021/03/15/dHWLUozpfnIGZJw.png" style="zoom:67%;" />

```c
typedef struct Node
{
  int data;
  struct Node *next;//指向Node型变量的指针
}Node;
```

* 二叉树的定义

```c
typedef struct BTNode
{
  int data;
  struct BTNode *lchild;
  struct BTNode *rchild;
}BTNode;
```

​	有些参考数喜欢在最后多加一个`*btnode`,而实际上，在定义指针的时候，`BTNode *p`就等价于`btnode p`,所以统一使用`BTNode`就能解决所有问题并且方便简洁。

##### 6.构建新结点：

以二叉树为例，有以下两种写法：

```c
// ①
BTNode BT; 
// ②
BTNode *BT;
BT=(BTNode*)malloc(sizeof(BTNode));
```

* ①一句就制作了一个结点，但要使BT可以离开当前结点而转向下一结点，使用①方法实现起来较为困难，所以考研中尽量使用②这一方法；
* ②的执行过程为：
  * 先定义一个结点指针`BT`；
  * 然后用函数`malloc()`来申请一个结点空间；
  * 最后让指针BT指向这一片内存空间；

<img src="https://i.loli.net/2021/03/15/gYG6OhTBAs9M7ow.png" style="zoom:67%;" />

同理，还可以通过`malloc()`函数来申请一个动态数组空间：

```c
int *p;
p=(int*)malloc(n*sizeof(int));
```

这样就申请了一个由指针p所指的(p指向数组中第一个元素地址)、元素类型为int的、长度为n的动态数组。使用方法与一般数组相同。

* 对于①和②中，BT取分量的操作是不同的
  * 对于①，若要取data域的值赋给x，应写为`x=BT.data`。**用结构体变量直接取分量，其操作用"."**;
  * 对于②，同样取data域的值赋给x，应写为`x=BT->data`。**用指向结构体变量的指针取分量，其操作用''->''**。
* 对于②中的BT指针，使用"."来取data值，可以写为`(*BT).data`（`(*BT).data`与BT->data是等价的）。

##### 7.关于typedef和#define：

* `typedef`可以理解为给现有的数据类型起一个新名字，如`typedef struct{...} TypeA;`即给`struct{...}`起了一个新名字`TypeA`;
* `#define`对考研数据结构没有什么贡献，认得就行；

##### 8.函数的引用型：

**引用型和非引用型：**

```c
int a;
void f(int x)
{
  ++x;
}
```

当运行以下两行代码：

```c
a=0;
f(a);
```

完成f()的调用后a的值并不会发生改变。若想让a依照函数体f()的操作来改变时，就要用到函数参数的引用型定义：

```c
void f(int &x)
{
  ++x;
}
```

可以理解为在运行`f(a)`时，`a`取代了x的位置，函数`f(a)`就是对`a`本身进行操作。

**指针型：**

若传入的变量的指针型变量

```c
void f(int *&x)//指针型变量在函数体中需要改变写法
{
  ++x;
}
```

**数组：**

​	对于数组来说，没有引用型和非引用型之分，可以理解为**只要数组作为参数，就都是引用型**。（可以这样理解但还不够准确）

​	一维数组作为参数的函数定义方法：

```c
void f(int x[],int n)
{
  ...;
}
```

第一个参数位置上 不需要限定数组的参数。

​	二维数组作为参数的函数定义方法： 

```c
void f(int x[][maxSize],int n)
{
  ...;
}
```

二维数组中第一个括号内也不需要写数组长度，但第二个括号内**必须写上数组长度**。

但要注意，**传入数组二维长度也得是maxSize**，否则出错

```c
void f(int x[][5])
{
  ...;
}
int a[10][5];
int b[10][3];
f(a);	//参数正确
f(b);	//参数错误
```

**结构体：**

```c
void insert(Sqlist &L,int x)
{
  ...;
}
```

这里`Sqlist`为结构体，即便其中含有数组，在函数调用中也要传入`L`的引用型。

**指针型：** 

```c
int SearchAndDelete(LNode *C,int x)
{
  ...;
}
```

这里C表示一个指向表头的指针，不需要引用型；

```c
void merge(LNode *A,LNode *B,LNode *&C)
{
  ...;
}
```

假设这里创建了一个函数`merge()`,作用是将A、B两个链表合并成一个，此时需要得到一个指向结果链表的指针，就是参数c。

C指针传入时可能是一个空指针，经过函数操作后它指向的结果链表的表头，即C自身发生了改变，所以这里C需要用引用型；而A、B没有改变的需要，所以不需要用引用型。

### 1.2 算法时间、空间复杂度分析

​	算法时间复杂度就是给出相应的数量级，当f(n)与n无关时，时间复杂度T(n)=O(1);当f(n)与n是线性关系时，T(n)=O(n)；当f(n)与n是二次方关系时，T(n)=O(n<sup>2</sup>);以此类推。

时间复杂度比较关系：

<center><font color="#dd0000">O(1)≤O(log<sub>2</sub>(n))≤O(n)≤O(nlog<sub>2</sub>(n))≤O(n<sup>2</sup>)≤O(n<sup>3</sup>)≤...≤O(n<sup>k</sup>)≤O(2<sup>n</sup>)></font></center>

> 注：有的算法中基本操作的执行次数不仅与初始输入的数据规模有关，还和数据本身有关。
>
> ​	这种情况下，一般依照使得基本操作执行次数最多的输入来计算时间复杂度，即**将最坏的情况作为算法时间复杂度的度量**。

##### 1.算法时间复杂度计算步骤：

**【例1】**以下面算法为例：

```c
void fun(int n)
{
  int i=1,j=100;
  while(i<n)
  {
    ++j;
    i+=2;
  }
}
```

* **第一步：找出基本操作，确定n的规模。**

  ​    `基本操作`即以求时间复杂度为目的的前提下，重复执行次数和算法执行时间成正比的操作。多数情况下取最深层循环内的语句所描述的操作作为基本操作。题目中，`++j`与`i+=2`,这两行都能作为基本操作。

  ​	`确定规模`。由循环条件`i<n`知，循环执行次数和参数`n`有关，因此`n`就是规模

* **第二步：计算n的函数f(n)。**

  ​	循环是否结束和i有关。i初值为1，每次自增2，设当i自增m次后循环结束，此时`i=1+2m`，有`1+2m+K=n`(K为一个常数，用来修正，并不会对最终时间复杂度产生影响)。

  ​	最后解得`m=(n-1-K)/2`,因此时间复杂度为`T(n)=O(n)`。

**【例2】**

```c
void fun(int n)
{
  int i,j,x=0;
  for(i=0,i<n;++i)
    for(j=i+1;j<n;++j)
      ++x;
}
```

* `++x`取内层循环为基本操作，n为规模；
* `f(n)=n(n-1)/2`,变化最快项n<sup>2</sup>/2,所以时间复杂度为`T(n)=O(n^2)`。

**【例3】**

```c
void fun(int n)
{
  int i=0,s=0;
  while(s<n)
  {
    ++i;
    s=s+i;
  }
}
```

* 假设执行m次结束，那么执行m次后s的值为s<sub>m</sub>=m(m+1)/2,则有`m(m+1)/2+K=n`;

$$
f(n)=\frac{-1+\sqrt{8n+1-8K} }{2}
$$

* 所以时间复杂度为
  $$
  T(n)=O(\sqrt{n} )
  $$

##### 2.空间复杂的分析

​	算法空间复杂的指算法在运行过程中所需**存储空间的度量**，主要考虑算法运行过程中临时占用的存储空间大小。

### 1.3 数据结构的基本概念

##### 1.基本概念

数据的三个层次：<font color="#dd0000">数据、数据元素、数据项</font>。

* `数据`：对客观事物符号表示(如整数、实数、字符串等)；
* `数据元素`（概念）：<font color="#dd0000">**数据**的**基本单位**，是数据结构这门课的最小单位，在计算机中作为一个整体考虑。</font>**一个数据元素可由若干个数据项组成**（如一本书的数目信息作为一个数据元素，那么数目信息的每一项书名、作者名等，都是一个数据项）。
* `数据项`:<font color="#dd0000">数据的最小单位</font>。
* `数据对象`（研究对象）：性质相同时数据元素集合，是数据的子集。



数据结构指相互间存在一种或多种特定关系的数据元素的集合。包括三个方面内容：

* <font color="#dd0000">`逻辑结构`、`存储结构`和`数据的运算（逻辑结构上所定义的操作）`</font>。



抽象数据类型（ADT）：

```c
ADT 抽象数据类型
{
  数据对象：（数据元素的集合）
  数据关系：（数据关系的二元组合）
  数据操作：（操作函数的罗列）
}
```

可以用抽象数据结构定义一个完整的数据结构。

##### 2.逻辑结构

* `数据的逻辑结构`：数据之间相互关系的描述，与数据存储结构无关，同一逻辑结构可以有多种存储结构。可分为以下两大类：
  * <font color="#dd0000">线性结构</font>：指数据元素之间存在着“一对一”的线性关系的数据结构；
  * <font color="#dd0000">非线性结构</font>：在非线性结构中结点存在“一对多的关系”，又可细分为树型结构和图型结构。

逻辑结构也可以分为集合、线性结构、树型结构、和图形（或网状）结构。

##### 3.物理结构

​	数据的物理结构又称为存储结构，是数据的逻辑结构在计算机中的表示（又称映像）。

​	当数据元素的由若干个数据项构成的时候,数据项的表示称为`数据域`。（如，一个链表结点，结点包括指针域和值域，指针域和值域都是这个数据元素的数据域）。

有以下4种常用的存储方法：

* 顺序存储。如数组；
* 链式存储。逻辑关系由附加指针字段表示；
* 索引存储。<关键字,地址>;
* 散列存储。通过散列函数直接计算结点存储地址。

### 1.4 算法的基本概念

`算法`：由基本运算规定的运算顺序所构成的完整解题步骤。

<font color="#dd0000">**算法特性：**</font>

* <font color="#dd0000">有穷性</font>:指算法必须保证执行有限步后结束；
* <font color="#dd0000">确定性</font>：算法的每一步骤必须有确切的定义，不能有二义性；
* <font color="#dd0000">输入</font>：0至多个输入；
* <font color="#dd0000">输出</font>:1至多个输出（必须有输出）；
* <font color="#dd0000">可行性（有效性）</font>：算法中执行的任何计算步骤都可以被分解为基本的可执行的操作步；

<font color="#dd0000">**算法设计目标：**</font>

* <font color="#dd0000">正确性</font>：指算法必须正确，目前可行的办法就是用苛刻的数据验证算法正确性；
* <font color="#dd0000">可读性</font>：指同行都容易读懂；
* <font color="#dd0000">健壮性</font>：对非法操作不参数莫名其妙的结果，更不能使程序中断，而该引导用户该如何操作；
* <font color="#dd0000">高效率与低存储量需求</font>：好的时空性能；

