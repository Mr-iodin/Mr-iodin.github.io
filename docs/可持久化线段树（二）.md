# 可持久化块线段树

###　1. 线段树

常用来维护区间信息。这里简单描述一下

![](https://i.loli.net/2020/07/19/gUvfVA8tz3QbEqe.jpg)

#### 1.1 结构

数组（开4*N足够）

```c++
int arr[maxn];//原来区间
int tr[maxn<<4];//线段树点
```

链表：

```c++
struct node
{
    int l,r,value;
    node *lchild,*rchild;
};
```

#### 1.2 建树

自顶向下递归。

```c++
void build(int i,int l,int r)//i当前下标，l、r区间左界右界.buile(1,1,n)
{
    if(l==r){
        tr[i]=arr[l];
        return;
    }
    int mid=(l+r)/2;
    build(i<<1,l,mid);
    build(i<<1|1,mid,r);
    tr[i]=max(tr[i<<1],tr[i<<1|1]);
}
```

#### 1.3 单点修改

```c++
void change(int i,int l,int r,int x,int addn)//当前下标i，l、r上下界，x目标结点，addn要加的值
{
    if(l==r){
        tr[i]+=addn;
        return;
    }
    int mid=(l+r)/2;
    if(x<mid)change(p*2,l,mid,x,addn);
    else
        change(p*2+1,mid,r,x,addn);
    tr[i]=max(tr[i<<1],tr[i<<1|1]);
}
```

#### 1.4 区间查询

```c++
int find(int i,int l,int r,int x,int y)//
{
    if(l<=x && r<=r)return tr[i];
    int mid=(l+r)/2;
    if(y<=mid) return find(p*2,l,mid,x,y);
    if(x>mid) return find(p*2+1,mid,r,x,y);
    return find(find(p*2,l,mid,x,mid),find(p*2+1,mid+1,r,mid+1,y));
}
```

#### 1.5 区间更新

...

### 2.可持久化线段树

可持久化线段树，也叫主席树，是线段树持久化操作后的结果，具有持久化数据结构的性质。

相比于上面所讲的线段树，在更新操作中，主席树尽可能的利用了两个版本间重复的部分，来减少空间复杂度。

![](https://i.loli.net/2020/07/19/mF1syRSItwuHcVa.jpg)

权值线段树：权值线段树树就是对值域上值的个数进行维护的线段树。

![](https://i.loli.net/2020/07/19/b4VC6BT2Fi8f3QK.jpg)

这部分还需要考虑一下怎么直观一点...

