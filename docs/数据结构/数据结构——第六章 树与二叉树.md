# 数据结构——第六章 树与二叉树

### 1.树的基本概念

​	树是一种非线性的数据结构。是由若干结点的集合，是由唯一的根和若干不相交的子树组成。

<img src="https://i.loli.net/2021/04/08/1dLNelGnhBbysR8.png" style="zoom:67%;" />

​	每一棵子树又是一棵树，也是由唯一的根结点和若干棵互不相交的子树组成的。

​	由此可知，树的定义是递归的，即在树的定义是递归的，即在树的定义中又用到了树的定义。

> 注：
>
> ​	树的结点可以为0，当为0时，这棵树称为一棵**空树**，这是一种特殊状况。	



**结点**：A、B、C等都是结点，结点不仅包含数据元素，而且包含指向子树的分支。（例如上图中A结点不仅包含元素A，而且包含3个指针）

**结点的度**：结点拥有的子树个数或者分支个数。（如上图中A的度为3）

**树的度**：树中各结点度的最大值。（如上图中树的度为3）

**叶子结点**：又叫做终端结点，指度为0的结点。（如F、G、I、L、J...）

**非终端结点**：又叫做分支结点，指度不为0的结点。（如A、B、C、D...）

**孩子**：结点子树的根。（A的孩子是B、C、D）

**双亲**：与孩子定义对应。（如B、C、D结点的双亲都是A）

**兄弟**：同一个双亲孩子之间互为兄弟，之间的孩子互为兄弟。（如B、C、D互为兄弟）

**祖先**：从根到某结点路径上的所有结点，都是这个结点的祖先。

**子孙**：以某结点为根结点的子树的所有结点，都是该结点的子孙。

**层次**：从根结点开始，根为第一层，根结点的孩子为第二层，根结点孩子的孩子为第三层。

**树的高度（深度）**：树中结点最大的层次。如上图中树共四层，所以高度为4。

**结点的深度和高度：**

* 结点的深度是从根结点到该结点路径上的结点个数；
* 从某结点往下走可能到达多个叶子结点，对应了多条通往这些叶子结点的路径，其中最长的那条路径上结点的个数即为该结点在树中的高度；（如D结点的高度为3）
* 根结点的高度即为树的高度。

**堂兄弟**：双亲在同一层的结点互为堂兄弟。（注意和兄弟区分）

**有序树**：树中结点的子树从左到右是有次序的，不能交换；

**无序树**：树中结点子树没有顺序，可以任意交换；

**丰满树：**即理想平衡树，要求除最底层外，其他层都是满的；

**森林**：若干颗互不相交的树的集合。

[这些概念用处不大]

### 2.树的存储结构

##### 2.1 顺序存储

​	树的顺序存储结构中最直观的树双亲存储结构。用一维数组就可以实现。		![](https://i.loli.net/2021/04/08/PHkdXxSnZvVrJmi.png)

​	如上图，定义一个数组`int tree[maxSize]`,数组元素的内容表示该结点的双亲结点，这样就有了结点（下标）以及结点之间的关系（内容），就可以表示一棵树了。（例如：下标5的内容为3，那么5的双亲结点就是3；下标1的内容为-1，表示1为根结点。）

​	这种存储结构很容易找到其双亲结点，因此称为双亲存储结构。

> 注：这种被简化的双亲存储结构仅包含了各个结点之间的关系信息，即每个结点中只保存了指示哪个结点是它的双亲结点的信息，这恰恰是考研重点考察的地方，也是双亲存储结构的核心。

##### 2.2 链式存储结构

树的链式存储最常用的有以下两种：

* 孩子存储结构

  实质上就是图的邻接表存储结构，树就是一种特殊的图，把多对多关系删减为一对多关系即得到树。

* 孩子兄弟存储结构



> 说明：
>
> ​		这两种存储结构可能在不同地方表述不同，最严格的表述如下
>
> * 树的顺序存储结构的双亲表示法；
> * 树的链式存储结构的孩子表示法或孩子兄弟表示法；



### 3.二叉树

##### 3.1二叉树的基本定义

​	在树的定义基础上添加了两个限制条件：

* 每个结点最多只有两颗子树，即二叉树中结点的度只能为0、1、2；
* 子树有左右顺序之分；

**二叉树的五种基本形态：**

![](https://i.loli.net/2021/04/08/D3byUxc6gYm4pvF.png)

a)空二叉树；

b)只有根结点；

c)只有左子树，右子树为空；

d)只有右子树，左子树为空；

e)既有左子树又有右子树；



**满二叉树：**在二叉树中，所有的分支结点都有左右孩子，并且叶子结点都集中在二叉树的最下层，则这样的二叉树被称为满二叉树；

<img src="https://i.loli.net/2021/04/08/JxePmpqWRDgV1vr.png"  />

满二叉树的编号约定为从1开始，从上到下，从左至右进行。

**完全二叉树：**如果对一棵深度为k、有n个结点的二叉树进行编号后，==各结点的编号==与==深度为k的满二叉树中相同位置上的结点的编号==均相同。

![](https://i.loli.net/2021/04/09/npZte69cbkKJYGi.png)

##### 3.2 二叉树的主要性质

* **==性质一==：**非空二叉树**叶子结点数**等于**双分支结点数**加一。即：
  $$
  n_0=n_2+1
  $$

> ​	证明：
>
> ​			设二叉树叶子结点数为n<sub>0</sub>,单分支结点数为n<sub>1</sub>,双分支结点数为n<sub>2</sub>，则总结点数为**n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>**。
>
> ​			在二叉树中，所有结点等于单分支结点数加上双分支结点数的两倍，即总分支数为**n<sub>1</sub>+2n<sub>2</sub>**。
>
> ​			由于二叉树中除根结点之外，每个结点都有唯一的一个分支指向它，因此二叉树中有**总分支数=总结点数-1**（适用与任何树）。
>
> ​			由此得到：**n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>-1=n<sub>1</sub>+2n<sub>2</sub>**
>
> ​			化简得：**n<sub>0</sub>=n<sub>2</sub>+1**

​	这一性质还能扩展，即在一棵度为m的树中，度为1度结点数为n<sub>1</sub>,度为2的结点数为n<sub>2</sub>,...,度为m的结点数为n<sub>m</sub>，则叶子结点数为：
$$
n_0=1+n_2+2n_3+...+(m-1)n_m
$$

* **==性质二==：**二叉树的**第i层**上最多有**2<sup>i-1</sup>**（i>=1）个结点。

  ​	结点最多的情况是满二叉树的情况，此时二叉树每一层结点数够层了一个首项为1，公比为2的等比数列。通项为2<sup>i-1</sup>,i为层号。

* **==性质三==：** **高度（或深度）为k**二叉树**最多有2<sub>k</sub>-1(k>=1)个结点**。

  ​	换句话说，满二叉树中前k层度结点个数为2<sup>k</sup>-1;

  ​	本条性质为性质2中等比数列前k项和问题。由等比数列求和公式可得结果，（1-2<sup>k</sup>）/(1-2)=2<sup>k</sup>-1

* **==性质四==：**有n个结点的完全二叉树，对各结点从上到下、从左到右依次编号（编号范围为1～n），则结点之间的关系如下：

  若i为某结点a的编号，则：

  * 如果i≠1，则a双亲结点编号为i/2(取下界)；

  * 如果2i+1<=n，则a右孩子的编号为2i+1;如果2i+>n,则a无右孩子；

    ![](https://i.loli.net/2021/04/09/yI1OGBftFv6W7z3.png)

    ​	令n为5，结点B的编号为2，2×2=4<5，因此编号为D的结点为B的左孩子；2×2+1=5<=5，所以编号为E的结点为B的右孩子。

    ​	对编号为3，因3×2=6>5，因此结点C无左孩子。对于结点E，编号为5，5/2（取下界）=2，即编号为2的结点B是其双亲结点。

    > 有些考题中，编号从0开始。以此类推可得到：
    >
    > ​		某结点a的编号为i，则其左孩子结点编号为2i+1，右孩子结点编号为2i+2；a的双亲结点编号为i/2（取整型上界）-1。

* **==性质五==：**函数`Catalan()`:给定n各个结点，能构成h(n)种不同的二叉树
  $$
  h(n)=\frac{\complement^{n}_{2n} }{n+1}
  $$

* **==性质六==：**具有n(n>=1)个结点的完全二叉树的高度（或深度）为$\left\lfloor log_{2}n\right\rfloor +1$。

  > 完全二叉树高度公式在考研数据结构中还有另一种表达形式：
  > $$
  > h=\left\lceil log_{2}\left( n+1\right)  \right\rceil  
  > $$
  > ​	这样表示也是对的，只是推倒过程中等式选择不同。

##### 3.3 二叉树的存储结构

* **顺序存储结构**

  ​	即用一个数组来存储二叉树，这种存储方法**最适用于完全二叉树**，**用于存储一般二叉树会浪费大量的存储空间**。

  ​	在存储完全二叉树时，只需将完全二叉树中结点的编号依次存入一个一维数组BTree[]中

  ![](https://i.loli.net/2021/04/09/uWi42mrRUJtYNng.png)

  定点A的下标为1，要得到A的左孩子结点只需访问`BTree[1*2]`即可。类似地，如果知道了一个结点i，如果2i不大于n，则i的左孩子结点就存在于`BTree[i*2]`中。

  ​	当然这种存储方式也有很大的局限性，就是不便存储任意形态的二叉树。

  

* 链式存储结构

  ​	观察二叉树的形态可以发现是一个根结点和两颗子树之间的关系，可以将结点结构设计如下：

  ![](https://i.loli.net/2021/04/09/6x51sDTFZtGJoVp.png)

  * **data**表示数据域，存储数据元素；
  * **lchild**和**rchild**分别表示左指针域和右指针域；

  这种存储结构又称之为**二叉链表存储结构**。

定义如下：

```c++
typedef struct BTNode
{
  char data;
  
  struct BTNode *lchild;
  struct BTNode *rchild;
}BTNode;
```

![](https://i.loli.net/2021/04/09/wbX1uJjsVAl3FKm.png)

##### 3.4 二叉树的遍历算法

* 先序遍历

  若二叉树为空树，则什么都不做。否则：

  * 访问根结点；
  * 先序遍历左子树；
  * 先序遍历右子树；

```c++
void preorder(BTNode *p)
{
  if(p!=NULL)
  {
    Visit(p);
    preorder(p->lchile);
    preorder(p->rchile);
  }
}
```



* 中序遍历

  若二叉树为空树，则什么都不做。否则：

  * 先序遍历左子树；
  * 访问根结点；
  * 先序遍历右子树；

```c++
void inoder(BTNode *p)
{
  if(p!=NULL)
  {
    ininoder(p->lchild);
    Visit(p);
    ininoder(p->lchild);
  }
}
```



* 后序遍历

  若二叉树为空树，则什么都不做。否则：

  * 先序遍历左子树；
  * 先序遍历右子树；
  * 访问根结点；

```c++
void inoder(BTNode *p)
{
  if(p!=NULL)
  {
    ininoder(p->lchild);
    ininoder(p->lchild);
    Visit(p);
  }
}
```



​	下图所示为指针p沿图中箭头所指路线遍历整个二叉树都过程。

![](https://i.loli.net/2021/04/09/T6tcyEIARdD3kar.png)

图中每个结点都要经过3次。

​	图的右边为程序模版：

* 若访问结点写在`（1）`处，则是先序遍历，即对应于图中每个结点，在p所走线路经过标号1处对其访问；
* 若访问结点写在`（2）`处，则是中序遍历，即对应于图中每个结点，在p所走线路经过标号2处对其访问；
* 若访问结点写在`（3）`处，则是后序遍历，即对应于图中每个结点，在p所走线路经过标号3处对其访问；



先序遍历输出序列为：A、B、C、D、E、F、G、H

中序遍历输出顺序为：C、B、E、D、F、A、H、G

后序遍历输出顺序为：C、E、F、D、B、H、G、A



还有一个重要结论：

​	**根据二叉树前、中、后3种遍历序列中的`前和中`、`中和后`两对遍历序列都可以唯一确定一棵二叉树，而根据`前和后`这对遍历序列则不能确定这棵二叉树。**



##### 3.5 实例

【例一】表达式$(a-(b+c))*(d/c)$存储在下图所示的二叉树结构中，

![](https://i.loli.net/2021/04/09/pUzBaQqDXC6cgoG.png)

编写程序求出该表达式的值。

【分析】

​	先求出左子树所表示的表达式的值，然后求右子树所表示的表达式的值，最后将两个结果相乘就是整个表达式的数值。

代码如下：

```c++
int comp(BTNode *p)
{
  int A,B;
  if(p!=NULL)
  {
    //若左右孩子都不为空，则为符号
    if(p->lchild!=NULL&&p->rchile!=NULL)
    {
      A=comp(p->lchild);
      B=comp(p->rchild);
      return op(A,B,p->data);
    }
    else//如果左右子树都为空，则为数值
      return p->data-'0';	
  }
  else
    return 0;
}
```

【例二】写一个算法求一颗二叉树的深度，二叉树以二叉链表为存储方式。

【分析】

​	若有一颗二叉树，左子树深度为**LD**，右子树深度为**RD**，则整棵二叉树的深度为：
$$
max\{LD,RD\}+1
$$
​	这对应于先遍历左子树，再遍历右子树，最后访问根结点。

【代码】

```c++
int getDepth(BTNode *p)
{
  int LD,RD;
  if(p==NULL)
    return 0;
  else
  {
    LD=getDepth(p->lchild);
    RD=getDepth(p->rchild);
    return (LD>RD?LD:RD)+1;
  }
}
```



【例三】

​	在一棵二叉树链表为存储结构的二叉树中，查找data阈值等于key的结点是否存在（找到任何一个满足要求的结点即可），如果存在，则将q指向该结点，否则q赋值为NULL,假设data为int型。

【分析】

​	因为题中二叉树各个结点data域的值没有任何规律，所以要判断是否存在等于key的结点，就需要把所有结点都遍历一遍。当然，这对遍历方法没有要求。

【代码】先序遍历

```c++
void search(BTNode *p,BTNode *&q,int key)
{
  if(p!=NULL)
  {
    if(p->data==key)
      q=p;
    else
    {
      search(p->rchild,key);
      search(p->lchild,key);
    }
  }
}
```

若要提高本题效率，可以考虑这样一种改进策略：当在左子树中找到满足要求的结点后，无需查找右子树，直接退回本层递归，也就是所谓的“剪枝”操作。

```c++
void search(BTNode *p,BTNode *&q,int key)
{
	if(p!=NULL)
	{
    if(p->data==key)
      q=p;
    else
    {
      search(p->lchild,q,key);
      if(q==NULL)
        search(p->rchild,q,key);
    }
	}
}
```

