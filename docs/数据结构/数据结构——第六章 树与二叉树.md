

# 数据结构——第六章 树与二叉树

### 1.树的基本概念

​	树是一种非线性的数据结构。是由若干结点的集合，是由唯一的根和若干不相交的子树组成。

<img src="https://i.loli.net/2021/04/08/1dLNelGnhBbysR8.png" style="zoom:67%;" />

​	每一棵子树又是一棵树，也是由唯一的根结点和若干棵互不相交的子树组成的。

​	由此可知，树的定义是递归的，即在树的定义是递归的，即在树的定义中又用到了树的定义。

> 注：
>
> ​	树的结点可以为0，当为0时，这棵树称为一棵**空树**，这是一种特殊状况。	



**结点**：A、B、C等都是结点，结点不仅包含数据元素，而且包含指向子树的分支。（例如上图中A结点不仅包含元素A，而且包含3个指针）

**结点的度**：结点拥有的子树个数或者分支个数。（如上图中A的度为3）

**树的度**：树中各结点度的最大值。（如上图中树的度为3）

**叶子结点**：又叫做终端结点，指度为0的结点。（如F、G、I、L、J...）

**非终端结点**：又叫做分支结点，指度不为0的结点。（如A、B、C、D...）

**孩子**：结点子树的根。（A的孩子是B、C、D）

**双亲**：与孩子定义对应。（如B、C、D结点的双亲都是A）

**兄弟**：同一个双亲孩子之间互为兄弟，之间的孩子互为兄弟。（如B、C、D互为兄弟）

**祖先**：从根到某结点路径上的所有结点，都是这个结点的祖先。

**子孙**：以某结点为根结点的子树的所有结点，都是该结点的子孙。

**层次**：从根结点开始，根为第一层，根结点的孩子为第二层，根结点孩子的孩子为第三层。

**树的高度（深度）**：树中结点最大的层次。如上图中树共四层，所以高度为4。

**结点的深度和高度：**

* 结点的深度是从根结点到该结点路径上的结点个数；
* 从某结点往下走可能到达多个叶子结点，对应了多条通往这些叶子结点的路径，其中最长的那条路径上结点的个数即为该结点在树中的高度；（如D结点的高度为3）
* 根结点的高度即为树的高度。

**堂兄弟**：双亲在同一层的结点互为堂兄弟。（注意和兄弟区分）

**有序树**：树中结点的子树从左到右是有次序的，不能交换；

**无序树**：树中结点子树没有顺序，可以任意交换；

**丰满树：**即理想平衡树，要求除最底层外，其他层都是满的；

**森林**：若干颗互不相交的树的集合。

[这些概念用处不大]

### 2.树的存储结构

##### 2.1 顺序存储

​	树的顺序存储结构中最直观的树双亲存储结构。用一维数组就可以实现。		![](https://i.loli.net/2021/04/08/PHkdXxSnZvVrJmi.png)

​	如上图，定义一个数组`int tree[maxSize]`,数组元素的内容表示该结点的双亲结点，这样就有了结点（下标）以及结点之间的关系（内容），就可以表示一棵树了。（例如：下标5的内容为3，那么5的双亲结点就是3；下标1的内容为-1，表示1为根结点。）

​	这种存储结构很容易找到其双亲结点，因此称为双亲存储结构。

> 注：这种被简化的双亲存储结构仅包含了各个结点之间的关系信息，即每个结点中只保存了指示哪个结点是它的双亲结点的信息，这恰恰是考研重点考察的地方，也是双亲存储结构的核心。

##### 2.2 链式存储结构

树的链式存储最常用的有以下两种：

* 孩子存储结构

  实质上就是图的邻接表存储结构，树就是一种特殊的图，把多对多关系删减为一对多关系即得到树。

* 孩子兄弟存储结构



> 说明：
>
> ​		这两种存储结构可能在不同地方表述不同，最严格的表述如下
>
> * 树的顺序存储结构的双亲表示法；
> * 树的链式存储结构的孩子表示法或孩子兄弟表示法；



### 3.二叉树

##### 3.1二叉树的基本定义

​	在树的定义基础上添加了两个限制条件：

* 每个结点最多只有两颗子树，即二叉树中结点的度只能为0、1、2；
* 子树有左右顺序之分；

**二叉树的五种基本形态：**

![](https://i.loli.net/2021/04/08/D3byUxc6gYm4pvF.png)

a)空二叉树；

b)只有根结点；

c)只有左子树，右子树为空；

d)只有右子树，左子树为空；

e)既有左子树又有右子树；



**满二叉树：**在二叉树中，所有的分支结点都有左右孩子，并且叶子结点都集中在二叉树的最下层，则这样的二叉树被称为满二叉树；

<img src="https://i.loli.net/2021/04/08/JxePmpqWRDgV1vr.png"  />

满二叉树的编号约定为从1开始，从上到下，从左至右进行。

**完全二叉树：**如果对一棵深度为k、有n个结点的二叉树进行编号后，==各结点的编号==与==深度为k的满二叉树中相同位置上的结点的编号==均相同。

![](https://i.loli.net/2021/04/09/npZte69cbkKJYGi.png)

##### 3.2 二叉树的主要性质

* **==性质一==：**非空二叉树**叶子结点数**等于**双分支结点数**加一。即：
  $$
  n_0=n_2+1
  $$

> ​	证明：
>
> ​			设二叉树叶子结点数为n<sub>0</sub>,单分支结点数为n<sub>1</sub>,双分支结点数为n<sub>2</sub>，则总结点数为**n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>**。
>
> ​			在二叉树中，所有结点等于单分支结点数加上双分支结点数的两倍，即总分支数为**n<sub>1</sub>+2n<sub>2</sub>**。
>
> ​			由于二叉树中除根结点之外，每个结点都有唯一的一个分支指向它，因此二叉树中有**总分支数=总结点数-1**（适用与任何树）。
>
> ​			由此得到：**n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>-1=n<sub>1</sub>+2n<sub>2</sub>**
>
> ​			化简得：**n<sub>0</sub>=n<sub>2</sub>+1**

​	这一性质还能扩展，即在一棵度为m的树中，度为1度结点数为n<sub>1</sub>,度为2的结点数为n<sub>2</sub>,...,度为m的结点数为n<sub>m</sub>，则叶子结点数为：
$$
n_0=1+n_2+2n_3+...+(m-1)n_m
$$

* **==性质二==：**二叉树的**第i层**上最多有**2<sup>i-1</sup>**（i>=1）个结点。

  ​	结点最多的情况是满二叉树的情况，此时二叉树每一层结点数够层了一个首项为1，公比为2的等比数列。通项为2<sup>i-1</sup>,i为层号。

* **==性质三==：** **高度（或深度）为k**二叉树**最多有2<sub>k</sub>-1(k>=1)个结点**。

  ​	换句话说，满二叉树中前k层度结点个数为2<sup>k</sup>-1;

  ​	本条性质为性质2中等比数列前k项和问题。由等比数列求和公式可得结果，（1-2<sup>k</sup>）/(1-2)=2<sup>k</sup>-1

* **==性质四==：**有n个结点的完全二叉树，对各结点从上到下、从左到右依次编号（编号范围为1～n），则结点之间的关系如下：

  若i为某结点a的编号，则：

  * 如果i≠1，则a双亲结点编号为i/2(取下界)；

  * 如果2i+1<=n，则a右孩子的编号为2i+1;如果2i+>n,则a无右孩子；

    ![](https://i.loli.net/2021/04/09/yI1OGBftFv6W7z3.png)

    ​	令n为5，结点B的编号为2，2×2=4<5，因此编号为D的结点为B的左孩子；2×2+1=5<=5，所以编号为E的结点为B的右孩子。

    ​	对编号为3，因3×2=6>5，因此结点C无左孩子。对于结点E，编号为5，5/2（取下界）=2，即编号为2的结点B是其双亲结点。

    > 有些考题中，编号从0开始。以此类推可得到：
    >
    > ​		某结点a的编号为i，则其左孩子结点编号为2i+1，右孩子结点编号为2i+2；a的双亲结点编号为i/2（取整型上界）-1。

* **==性质五==：**函数`Catalan()`:给定n各个结点，能构成h(n)种不同的二叉树
  $$
  h(n)=\frac{\complement^{n}_{2n} }{n+1}
  $$

* **==性质六==：**具有n(n>=1)个结点的完全二叉树的高度（或深度）为$\left\lfloor log_{2}n\right\rfloor +1$。

  > 完全二叉树高度公式在考研数据结构中还有另一种表达形式：
  > $$
  > h=\left\lceil log_{2}\left( n+1\right)  \right\rceil  
  > $$
  > ​	这样表示也是对的，只是推倒过程中等式选择不同。

##### 3.3 二叉树的存储结构

* **顺序存储结构**

  ​	即用一个数组来存储二叉树，这种存储方法**最适用于完全二叉树**，**用于存储一般二叉树会浪费大量的存储空间**。

  ​	在存储完全二叉树时，只需将完全二叉树中结点的编号依次存入一个一维数组BTree[]中

  ![](https://i.loli.net/2021/04/09/uWi42mrRUJtYNng.png)

  定点A的下标为1，要得到A的左孩子结点只需访问`BTree[1*2]`即可。类似地，如果知道了一个结点i，如果2i不大于n，则i的左孩子结点就存在于`BTree[i*2]`中。

  ​	当然这种存储方式也有很大的局限性，就是不便存储任意形态的二叉树。

  

* 链式存储结构

  ​	观察二叉树的形态可以发现是一个根结点和两颗子树之间的关系，可以将结点结构设计如下：

  ![](https://i.loli.net/2021/04/09/6x51sDTFZtGJoVp.png)

  * **data**表示数据域，存储数据元素；
  * **lchild**和**rchild**分别表示左指针域和右指针域；

  这种存储结构又称之为**二叉链表存储结构**。

定义如下：

```c++
typedef struct BTNode
{
  char data;
  
  struct BTNode *lchild;
  struct BTNode *rchild;
}BTNode;
```

![](https://i.loli.net/2021/04/09/wbX1uJjsVAl3FKm.png)

##### 3.4 二叉树的遍历算法（递归）

* 先序遍历

  若二叉树为空树，则什么都不做。否则：

  * 访问根结点；
  * 先序遍历左子树；
  * 先序遍历右子树；

```c++
void preorder(BTNode *p)
{
  if(p!=NULL)
  {
    Visit(p);
    preorder(p->lchile);
    preorder(p->rchile);
  }
}
```



* 中序遍历

  若二叉树为空树，则什么都不做。否则：

  * 先序遍历左子树；
  * 访问根结点；
  * 先序遍历右子树；

```c++
void inoder(BTNode *p)
{
  if(p!=NULL)
  {
    ininoder(p->lchild);
    Visit(p);
    ininoder(p->lchild);
  }
}
```



* 后序遍历

  若二叉树为空树，则什么都不做。否则：

  * 先序遍历左子树；
  * 先序遍历右子树；
  * 访问根结点；

```c++
void inoder(BTNode *p)
{
  if(p!=NULL)
  {
    ininoder(p->lchild);
    ininoder(p->lchild);
    Visit(p);
  }
}
```



​	下图所示为指针p沿图中箭头所指路线遍历整个二叉树都过程。

![](https://i.loli.net/2021/04/09/T6tcyEIARdD3kar.png)

图中每个结点都要经过3次。

​	图的右边为程序模版：

* 若访问结点写在`（1）`处，则是先序遍历，即对应于图中每个结点，在p所走线路经过标号1处对其访问；
* 若访问结点写在`（2）`处，则是中序遍历，即对应于图中每个结点，在p所走线路经过标号2处对其访问；
* 若访问结点写在`（3）`处，则是后序遍历，即对应于图中每个结点，在p所走线路经过标号3处对其访问；



先序遍历输出序列为：A、B、C、D、E、F、G、H

中序遍历输出顺序为：C、B、E、D、F、A、H、G

后序遍历输出顺序为：C、E、F、D、B、H、G、A



还有一个重要结论：

​	**根据二叉树前、中、后3种遍历序列中的`前和中`、`中和后`两对遍历序列都可以唯一确定一棵二叉树，而根据`前和后`这对遍历序列则不能确定这棵二叉树。**



* 层次遍历

​    从根部依次向下按层次从左到右进行遍历（当然也可以从右到左）。

<img src="https://i.loli.net/2021/04/10/4ValcJNoGsCdhfr.png" style="zoom:50%;" />



​	要进行层次遍历，需要建立一个循环队列。先将二叉树树头结点入队列，然后出队列，访问该结点。如果它有左子树，则将左子树的根结点入队，如果它有右子树，则将右子树的根结点入队列，对出队列结点访问。如此反复。

```c++
void level(BTNode *p)
{
  int front,rear;
  //定义一个循环队列，用来记录将要访问的层次上的结点
  BTNode *que[maxSize];
  front=rear=0;
  if(p!=NULL)
  {
    rear=(rear+1)%maxSize;
    que[rear]=p;
    while(front!=rear)
    {
      front=(front+1)%maxSize;
      q=que[front];	//队头结点出队
      Visit(q);	//访问队头结点
      if(q->lchild!=NULL)//若左子树不为空， 将左子树根结点入队
      {
        rear=(rear+1)%maxSize;
        que[rear]=q->lchild;
      }
      if(q->rchild!=NULL)//若右子树不为空，将右子树的根结点入队
      {
        rear=(rear+1)%maxSize;
        que[rear]=q->rchild;
      }
    }
  }
}
```

【上边的代码要求在理解下记忆，达到可以熟练默写的程度。】

##### 3.5 二叉树遍历算法的改进（栈）

​	上边介绍的二叉树深度优先遍历算法是由递归函数实现的，这是很低效的，原因在于系统帮你调了一个栈并做了诸如保护现场和恢复的操作，所以才使得遍历可以用非常简洁的代码实现。

​	本节介绍两种算法：

* 第一种：用用户定义的栈来替代系统栈，也就是用非递归的方式来实现遍历算法；

  > 为什么自己定义的栈要比系统栈高效？
  >
  > ​	通俗的解释是：递归函数所申请的系统栈，是所有递归函数都通用的栈。
  >
  > ​	对于二叉树深度优先遍历算法，系统栈除了记录访问过的结点信息之外，还有其他信息需要记录，以实现函数的递归调用。
  >
  > ​	用户自己定义的栈仅保存了遍历所需的结点信息，是对遍历算法的一个针对性设计。
  >
  > ​	所以在这种情况下，专业的要比通用的要好一些。	

  

* 第二种：将二叉树线索化，不需要栈来辅助完成遍历操作，更进一步提高效率。





**深度优先**

* 先序遍历的非递归算法

<img src="https://i.loli.net/2021/04/10/3fHlz2EUQmgiJI1.png" style="zoom:50%;" />

​	以上边的二叉树为例，各个结点进栈、出栈。

![](https://i.loli.net/2021/04/10/Ta6CGeqvIEo3w2Z.png)

① 结点1入栈；

② 出栈，输出栈顶结点1，并将1的左、右孩子结点（2和4）入栈；右孩子先入栈，左孩子后入栈，因为对左孩子的访问要先于右孩子，后入栈的会先出栈访问；

③ 出栈，输出栈顶结点2，并将2的左、右孩子结点（3和5）入栈；

④ 出栈，输出栈顶结点3，3为叶子结点，无孩子，本步无结点入栈；

⑤ 出栈，输出栈顶结点5；

出栈，输出栈顶结点4，此时栈空，进入终态。

```c++
void preorderNonrecursion(BTNode *bt)
{
  if(bt!=NULL)
  {
    BTNode *Stack[maxSize];
    int top=-1;
    BTNode *p;
    Stack[++top]=bt;
    while(top!=-1)
    {
      p=Stack[top--];
      Visit(p);
      if(p->rchild!=NULL)
        Stack[++top]=p->rchild;
      if(p->lchild!=NULL)
        Stack[++top]=p->lchild
    }
  }
}
```



* 中序遍历非递归算法

<img src="https://i.loli.net/2021/04/10/3fHlz2EUQmgiJI1.png" style="zoom:50%;" />

![](https://i.loli.net/2021/04/11/sfBZjGR2xCOLlKk.png)

① 结点1入栈，1的左孩子存在；

② 结点2入栈，2的左孩子存在；

③ 结点3入栈，3的左孩子不存在；

④ 3出栈，3的右孩子不存在；

⑤ 2出栈，2的右孩子存在，5入栈，5的左孩子不存在；

⑥ 5出栈，5的右孩子不存在；

⑦ 1出栈，1的右孩子存在，4入栈，4的左孩子不存在；

出栈，输出栈顶结点4，此时栈为空，进入终态。

遍历序列为3，2，5，1，4 。

**整个非递归遍历可以总结如下：**

1. 开始时根结点入栈；
2. 循环如下操作：如果栈顶结点左孩子存在，则左孩子入栈；如果栈顶结点左孩子不存在，则出栈并输出栈顶结点，然后检查其右孩子是否存在，如果存在，则右孩子入栈；
3. 当栈空时算法结束。



* 后序遍历非递归算法

<img src="https://i.loli.net/2021/04/10/3fHlz2EUQmgiJI1.png" style="zoom:50%;" />

先序遍历序列：1、2、3、5、4；

后序遍历序列：3、5、2、4、1；

把后序序列逆序得：1、4、2、5、3；

​	通过观察可以发现先序遍历与后序遍历 存在一定联系，**逆后序遍历序列只不过是先序遍历过程中对左右子树遍历顺序交换所得到的结果**。

具体如下图所示：

<img src="https://i.loli.net/2021/04/11/7fGF8C15owjpNPg.png" style="zoom: 67%;" />

​	后序遍历结点进出栈过程：

<img src="https://i.loli.net/2021/04/11/s7jfoUu2KwX4RVb.png" style="zoom: 50%;" />

①结点1入`stack1`；

② `stack1`元素出栈，并将出栈结点1入`stack2`，结点1点左、右孩子存在，左孩子结点2入`stack1`,右孩子结点4入`stack1`；

③ `stack1`元素出栈，并将出栈结点4入`stack2`,结点4的左、右孩子不存在；

④ `stack1`元素出栈，并将出栈结点2入`stack2`,结点2的左、右孩子存在，左孩子结点3入 `stack1`，右孩子结点5入`stack1`；

⑤ `stack1`元素出栈，并将出栈结点5入`stack2`；

⑥ `stack1`元素出栈，并将出栈结点3入`stack2`。

​	此时`stack1`空，`stack2`中元素自顶向下依次为：3、5、2、4、1.正好为后序遍历；

代码如下：

```c++
void postorderNonrecursion(BTNode *bt)
{
  if(bt!=NULL)
  {
    //定义两个栈
    BTNode *Stack1[maxSize];int top1=-1;
    BTNode *Stack1[maxSize];int top2=-1;
    BTNode *p=NULL;
    
    while(top1!=-1)
    {
      p=Stack[top1--];
      Stack2[++top2]=p;
      
      //先左孩子后右孩子
      if(p->lchild!=NULL)
        Stack1[++top1]=p->lchild;
      if(p->rchild!=NULL)
        Stack1[++top1]=p->rchild;
    }
    
    while(top2!=-1)
    {
      //出栈序列即为后序遍历序列
     	p=Stack2[top2--];
      Visit(p);
    }
    //下边的循环完成中序遍历。出栈过程在
  }
}
```



##### 3.6二叉树遍历算法的改进（线索）

​	二叉树非递归遍历算法避免了系统栈的调用，提高了一点的执行效率。本节采用线索可以把用户栈也省掉，进一步提高效率。

​	对于二叉树链式存储结构，n个结点的二叉树有n+1个空链域。在一般的二叉树中，我们只知道某个结点的左、右孩子，并不能知道某个结点在某种遍历方式下的直接前驱和直接后续，如果能够知道“前驱”和“后续”信息，就可以把二叉树看作一个链式结构，从而可以像遍历链表那样来遍历二叉树，进而提高效率。





* 中序线索二叉树的结点结构如下

![](https://i.loli.net/2021/04/11/bIfSOErcw68MntG.png)

​	在二叉树线索化的过程中会把树中的空指针利用起来做为寻找当前结点前驱和后续的线索，这样就出现了一个问题：线索和树中原有指向孩子结点的指针无法区分。

​	为了区分这两类指针，ltag和rtag为标识域，它们的具体意义如下：

* 如果`ltag=0`,则表示`lchild`为指针，指向结点的左孩子；如果`ltag=1`，则表示`lchild`为线索，指向结点的直接前驱；
* 如果`rtag=0`,则表示`rchild`为指针，指向结点的右孩子；如果`rtag=1`，则表示`rchild`为线索，指向结点的直接后序；



对应的线索二叉树的结点定义如下：

```c++
typedef struct TBTNode
{
  char data;
  int ltag,rtag;
  struct TBTNode *lchild;
  struct TBTNode *rchild;
}TBTNode;
```

​	线索二叉树可以分为前序线索二叉树、中序线索二叉树和后序线索二叉树。对一棵二叉树中所有结点的空指针域按照某种遍历方式加线索的过程叫做线索化，被线索化了的二叉树称为线索二叉树。

![](https://i.loli.net/2021/04/11/tWEF1KjwGD6TieQ.png)



上图中序遍历结果为：B、D、A、E、C

二叉树中序线索化分析：

* 既然要对二叉树进行中序线索化，首先要有个中序遍历的框架，这里采用二叉树中序递归遍历算法，在遍历过程中连接上合适的线索即可。

* 线索化的规则是，**左线索指针指向当前结点在中序遍历序列中的前驱结点，右线索指针指向后继结点**。我们需要一个指针p指向当前正在访问的结点，pre指向p的前驱结点，p的左线索如果存在则让其指向pre，pre的右线索如果存在则让其指向p，因为p是pre的后继结点，这样就完成了一对线索的连接。

  如上图所示，某一时刻p指向A，pre指向了中序遍历过程中A的前驱D，A是D的后继，D的右线索存在则指向A。

  按照这一规则进行下去，当整颗二叉树遍历完成的时候，线索化就完成了。

* 上一步中保持pre始终指向p前驱的具体过程是，当p将要离开一个访问过的结点时，pre指向p；当p来到一个新结点时，pre显然指向的是此时p所指结点前驱结点。



**中序遍历构建线索二叉树：**

通过中序遍历对二叉树线索化的递归算法如下：

```c++
void InThread(TBTNode *p,TBTNode *&pre)
{
  if(p!=NULL)
  {
    InTread(p->lchild,pre);	//递归，左子树线索化
    if(p->lchild==NULL)
    {
      p->lchild=pre;
      p->ltag=1;
    }
    if(pre!=NULL&&pre->rchild==NULL)
    {
      pre->rchild=p;
      pre->rtag=1;
    }
    pre=p;	//pre指向当前的p
    p=p->rchild;	//p指向新结点，
    
    InThread(p,pre);	//递归，右子树线索化
  }
}
```

通过中序遍历建立中序线索二叉树的主程序如下：

```c++
void createInThread(TBTNode *root)
{
  TBTNode *pre=NULL;
  if(root!=NULL)
  {
    InThread(root,pre);
    pre->rchild=NULL;	//非空二叉树，线索化
    pre->rtag=1;	//后处理中序最后一个结点
  }
}
```



**中序线索二叉树的遍历：**

访问中序遍历第一个结点：

```c++
TBTNode *First(TBTNode *p)
{
  while(p->ltag==0)
    p=p->lchild;
  return p;
}
```

结点p在中序下的后继结点算法如下：

```c++
TBTNode *Next(TBTNode *p)
{
  if(p->rtag==0)
    return First(p->rchild);
  else
    return p->rchild;
}
```

最后可以写出二叉树在中序线索二叉树上执行中序遍历的算法

```c++
void Inoder(TBTNode *root)
{
  for(TBTNode *p=First(root);p!=NULL;p=Next(p))
    Visit(p);
}
```



**前序线索二叉树的遍历：**

```c++
void preThread(TBTNode *p,TBTNode *&pre)
{
  if(p!=NULL)
  {
    if(p->lchild==NULL)
    {
      p->lchild=pre;
      p->ltag=1;
    }
    if(pre!=NULL&&pre->rchild==NULL)
    {
      pre->rchild=p;
      pre->rtag=1;
    }
    pre=p;
    
    //递归入口有限制条件，只有左、右指针不是线索才能继续递归
    if(p->ltag==0)
      preThread(p->lchild,pre);
    if(p->rtag==0)
      preThread(p->rchild,pre);
  }
}
```

前序线索二叉树上执行前序遍历的算法如下：

```c++
void preorder(TBTNode *root)
{
  if(root!=NULL)
  {
    TBTNode *p=root;
    while(p!=NULL)
    {
      while(p->ltag==0)
      {
        Visit(p);
        p=p->lchild;
      }
      Visit(p);
      p=p->rchild;
    }
  }
}
```

* 后序线索二叉树

把连接线索的代码放到了两递归入口的后边。

```c++
 void postThread(TBTNode *p,TBTNode *&pre)
 {
   if(p!=NULL)
   {
     postThread(p->lchild,pre);
     postThread(p->rchild,pre);
     
     if(p->lchild==NULL)
     {
       p->lchild=pre;
       p->ltag=1;
     }
     
     if(pre!=NULL&&pre->rchild==NULL)
     {
       pre->rchild=p;
       pre->rtag=1;
     }
     pre=p;
   }
 }
```

> 说明：
>
> ​	对于后序线索二叉树的遍历，考研数据结构中出现的题目最多的是手工找到当前结点的后继，记住以下3点即可：
>
> * 若x是二叉树的根，则其后继为空；
> * 若x是其双亲的右孩子，或者其双亲左孩子且其双亲没有右子树，则其后继即为双亲结点；
> * 若x是其双亲的左孩子，且其双亲有右子树，则其后继伟双亲右子树上按后序遍历列出的第一个结点。

![](https://i.loli.net/2021/04/12/hdGgm7B4vzi69AX.png)

##### 3.7 实例

【例一】表达式$(a-(b+c))*(d/c)$存储在下图所示的二叉树结构中，

<img src="https://i.loli.net/2021/04/09/pUzBaQqDXC6cgoG.png" style="zoom:50%;" />

编写程序求出该表达式的值。

【分析】

​	先求出左子树所表示的表达式的值，然后求右子树所表示的表达式的值，最后将两个结果相乘就是整个表达式的数值。

代码如下：

```c++
int comp(BTNode *p)
{
  int A,B;
  if(p!=NULL)
  {
    //若左右孩子都不为空，则为符号
    if(p->lchild!=NULL&&p->rchile!=NULL)
    {
      A=comp(p->lchild);
      B=comp(p->rchild);
      return op(A,B,p->data);
    }
    else//如果左右子树都为空，则为数值
      return p->data-'0';	
  }
  else
    return 0;
}
```

【例二】写一个算法求一颗二叉树的深度，二叉树以二叉链表为存储方式。

【分析】

​	若有一颗二叉树，左子树深度为**LD**，右子树深度为**RD**，则整棵二叉树的深度为：
$$
max\{LD,RD\}+1
$$
​	这对应于先遍历左子树，再遍历右子树，最后访问根结点。

【代码】

```c++
int getDepth(BTNode *p)
{
  int LD,RD;
  if(p==NULL)
    return 0;
  else
  {
    LD=getDepth(p->lchild);
    RD=getDepth(p->rchild);
    return (LD>RD?LD:RD)+1;
  }
}
```



【例三】

​	在一棵二叉树链表为存储结构的二叉树中，查找data阈值等于key的结点是否存在（找到任何一个满足要求的结点即可），如果存在，则将q指向该结点，否则q赋值为NULL,假设data为int型。

【分析】

​	因为题中二叉树各个结点data域的值没有任何规律，所以要判断是否存在等于key的结点，就需要把所有结点都遍历一遍。当然，这对遍历方法没有要求。

【代码】先序遍历

```c++
void search(BTNode *p,BTNode *&q,int key)
{
  if(p!=NULL)
  {
    if(p->data==key)
      q=p;
    else
    {
      search(p->rchild,key);
      search(p->lchild,key);
    }
  }
}
```

​	若要提高本题效率，可以考虑这样一种改进策略：当在左子树中找到满足要求的结点后，无需查找右子树，直接退回本层递归，也就是所谓的“剪枝”操作。

```c++
void search(BTNode *p,BTNode *&q,int key)

{
	if(p!=NULL)
	{
    if(p->data==key)
      q=p;
    else
    {
      search(p->lchild,q,key);
      if(q==NULL)
        search(p->rchild,q,key);
    }
	}
}
```



【例四】

​	假设二叉树采用二叉链表存储结构存储，编写一个程序，输出先序遍历序列中第k个结点的值，假设k不大于总代结点数（结点data域类型为char型）。

【分析】

​	既然题目要求输出先序遍历序列中的第k个元素的值，可以使用计数器和先序遍历进行迭代（当然也可以采用其他遍历方法）。

【代码】

* 先序

```c++
int n=0;
void trave(BTNode *p,int k)
{
  if(p!=NULL)
  {
    ++n;
    if(k==n)
    {
      cout<<p->data<<endl;
      return ;
    }
    trave(p->lchild,k);
    trave(p->rchild,k);
  }
}
```

* 中序

```c++
void trave(BTNode *p,int k)
{
 if(p!=NULL)
 {
   trave(p->lchild,k);
   ++n;
   if(k==n)
   {
     cout<<p->data<<endl;
     return ;
   }
   trave(p->rchild,k);
 }
}
```

* 后序

```c++
void trave(BTNode *p,int k)
{
  if(p!=NULL)
  {
    trave(p->lchild,k);
    trave(p->rchild,k);
    if(k==n)
    {
      cout<<p->Data<<endl;
      return ;
    }
  }
}
```



【例五】

​	假设二叉树采用二叉链表存储结构存储，设计一个算法，求出该二叉树的宽度（具有结点数最多的那一层上的结点个数）。

【分析】

两个要点：

* 对于非空树，树根所在层为第一层，并且从层次遍历算法程序中可以发现，有一个由当前结点找到其左、右孩子结点的操作。
* 在层次遍历中，用到了循环队列（队列用数组表示），其出队和入队操作分别为`front=(front+1)$maxSize`和`rear=(rear+1)%maxSize`;可以用`++rear`代替。

​    由第一点可以计算出所有结点的层号；由第二点可以知道所访问的结点最终保存在数组里。进而可以求出含有结点最多的层上结点数。

【代码】

```c++
typedef struct
{
  BTNode *p;	//结点指针
  int lno;	//结点所在的层次号
}St;

int maxNode(BTNode *b)
{
  St que[maxSize];
  int front,rear;	//定义顺序非空循环队列
  int Lno=0;i,j;n,max=0;
  front=rear=0;	//将队列置空
  
  BTNode *q;
  if(b!=NULL)
  {
    ++rear;
    que[rear].p=b;	//树根入队
    que[rear].lno=l;	//树根所在的层次号设置为1，此为已知条件
    while(front!=rear)	//若队列不为空
    {
      ++front;
      q=que[front].p;
      Lno=que[front].lno;	//关键句：Lno用来存取当前结点的层次号
      if(q->lchild!=NULL)
      {
        ++rear;
        que[rear].p=q->child;
        que[rear].lno=Lno+1;.//关键句：根据当前结点的层次号推之其子孩子结点的层次号
      }
      if(q->rchild!=NULL)
      {
        ++rear;
        que[rear].p=q->rchild;
        que[rear].lno=Lno+1;//关键句：根据当前结点的层次号推之其子孩子结点的层次号
      }
      if(q->rchild!=NULL)
      {
        ++rear;
        que[rear].p=q->rear;
        que[rear].lno=Lno+1;
        //关键语句：根据当前结点的层次号推知其孩子结点的层次号
      }
    }//循环结束后Lno中保存的是这颗二叉树的最大层数
    /*以下代码找出了含有结点最多的层中的结点数*/
    max=0;
    for(i=1;i<=Lno;++i)
    {
      n=0;
      for(j=0;j<=Lno;++i)
        if(que[j].lno==i)
          ++n;
      if(max<n)
        max=n;
    }
    return max;
  }
  else
    return 0;	//空树直接返回0
}
```



### 4.树和森林与二叉树的互相转换

​	前边提到的孩子兄弟存储结构是基于二叉链表实现的，即以二叉链表作为树的存储结构，只是结点中的指针域表示的意义不同，对比如下：

* 用二叉链表存储二叉树，结点中一个指针域叫作`lchild`,指向左孩子，另一个指针域叫作`rchild`，指向右孩子；
* 用二叉链表存储树，结点中的一个指针（假设叫`child`）指向一个孩子，另一个指针（假设叫`sibling`）指向自己的兄弟结点。

![](https://i.loli.net/2021/04/12/wzjQEcsN5gf39UK.png)

如上图所示，最左边是一棵树，最右边是这颗树转化为二叉树后存储在二叉链表中的情形。A结点的`child`指向了自己的孩子B结点，A结点没有兄弟结点，因此`sibling`为空；再看到B的结点，B没有孩子结点，因此`child`为空，B的`sibling`指向了自己的兄弟结点C。

​	因此，如果要找的A的孩子结点D，只需要`A->child->sibling->sibling`即可。



##### 4.1 树和二叉树之间相互转换

**树转化为二叉树：**

将树转化为二叉树的过程如下

* 将同一结点的各孩子结点用线串起来；

<img src="https://i.loli.net/2021/04/12/fGe5u3svBXlpjWm.png" style="zoom:50%;" />

* 将个结点的分支从左到右除了第一个以外，其余的都剪掉。

<img src="https://i.loli.net/2021/04/12/brIO2xdDw9alKuQ.png" style="zoom:50%;" />

* 整理结点使之符合二叉树的层次结构；



**二叉树转化为树：**

![](https://i.loli.net/2021/04/12/F5Q4VeLRmhs7baC.png)

* 如a)所示是一棵二叉树，先从它从左上到右下分为若干层；

  如`A`是第一层，`B-C-D`是一层，`E-F`是一层，然后调整水平方向，如b)所示；

* 找到每一层结点在其上一层的父结点。如第三层中，E、F的父结点为C，因为E和C相连；在第二层中，结点B、C、D在上一层的父结点为A，因为B和A相连；
* 将每一层的结点和其父结点相连。，然后删除每一层结点之间的连接,如c)所示。

##### 4.2 森林与二叉树之间的相互转换

**森林转化为二叉树：**

​	可以把这个过程看作树转化为二叉树的扩展，只不过是由原来的一棵树转化扩展为多棵树的转化。

​	要注意的是，要求是将森林转化为一棵二叉树，因此将森林中的每棵树分别转化后得到的多棵二叉树按照一定规律连接成一棵二叉树。根据孩子兄弟表示法规则，由于树的根结点一定是没有右兄弟的，因此转换为二叉树后，根结点一定没有右孩子。

​	那么可以将根结点这个空出来的右孩子指针利用起来，即将森林中的第二棵树转换成的二叉树，当作第一棵树根的右子树；

​	将森林中第三棵树转换成二叉树，当作第二棵树根右子树......以此进行，最终实现将森林转化成一棵二叉树；

<img src="https://i.loli.net/2021/04/12/6JciCaekKO9EmAL.png" style="zoom:67%;" />

以上边三颗二树为例：

* 首先将三颗树转化成二叉树：

  <img src="https://i.loli.net/2021/04/12/daPBLluYS2GxgRD.png" style="zoom:50%;" />

* 将第二棵二叉树作为第一棵二叉树根的右子树，将第三颗二叉树作为第二棵二叉树的右子树；

  <img src="https://i.loli.net/2021/04/12/aiXBOTYEIQmohxz.png" style="zoom:50%;" />

**二叉树转化为森林：**

原理就是上边过程的逆过程，只需要不停地将根结点有右孩子的二叉树的右连接断开，直到不存在根结点有右孩子为止；然后再按照将二叉树转化成树的规则转化即可；

### 5.树和森林的遍历

##### 5.1 树的遍历

树的遍历分为两种方式：**先序遍历**、**后序遍历**；

* 先序遍历

  <img src="https://i.loli.net/2021/04/12/9LUoJGaHAKwIV8r.png" style="zoom: 67%;" />

  * 先访问根结点；
  * 访问A的第一子树，访问子树时先访问根结点B；
  * 访问B的第一个孩子E；
  * 访问子树的第二个孩子F；
  * 访问A的第二棵子树，访问子树时先访问根结点C；
  * ...

  最后的遍历结果为：ABEFCGDHIJ



* 后序遍历

  后序遍历根结点的第一棵子树，然后再访问根结点。

  * 访问A的第一棵子树，访问子树时先访问根B的第一个孩子E；
  * 访问B的第二个孩子F；
  * 访问B；
  * 访问A的第二棵子树，访问子树时先访问根C的第一个孩子G；
  * ...

  最后的遍历结果为：EFBGCHIJDA；



当树转化为二叉树后，`树的先序遍历`对应`二叉树的先序遍历`,==树的后序遍历对应二叉树的中序遍历==；

##### 5.2 森林的遍历

森林的遍历方式有两种：**先序遍历**和**后序遍历**；

* 先序遍历过程

  先访问森林中的第一棵树的根结点，然后先序遍历第一棵树中根结点的子树，最后先序遍历森林中除了第一棵树以外的其他树；

* 后序遍历过程

  后序遍历第一棵树中根结点的子树，然后访问第一棵树的根的根结点,最后后序遍历森林中除去第一棵树以后的森林；

> 在不同的教程中，会将森林的后序遍历称为中序遍历，
>
> ​	这里说明：森林的后序遍历和森林的中序遍历是一样的，只是表述方式不同。但大多数都称为森林的后序遍历。

### 6.树与二叉树的应用

##### 6.1 二叉排序树和平衡二叉树

（暂略）

##### 6.2 霍夫曼树

霍夫曼树也叫最优二叉树，它的特点是带权路径最短。

**基本概念：**

* `路径`：路径上指从树中一个结点到另一个结点的分支，所构成的路径；
* `路径长度`：路径长度指路径上的分支数目
* `树的路径长度`：树的路径长度是指从根到每个结点的路径长度之和；
* `带权路径长度`：结点具有权值，从该结点到根之间的路径长度乘以结点权值，就是该结点的带权路径长度；
* `树的带权路径长度（WPL）`：树的带权路径长度是指树中所有叶子结点的带权路径长度之和。

<img src="https://i.loli.net/2021/04/12/HeCi5DgqUEM2l7S.png" style="zoom:50%;" />

如上图，假设四个叶子结点a、b、c、d的权重分别为7、5、2、4。

那么，a的`路径长度`为2,`带权路径长度`为7*2=14。同样，b、c、d的带权路径长度分别为2\*5=10、3\*2=6、2\*4=8，所以整棵`树的带权路径长度`为WPL=14+10+6+8=38。



**霍夫曼树的构建方法：**

​	给定n个权重，用这n个权重构造霍夫曼树的算法如下：

* 将这n个权重分别看作只有根结点的n棵二叉树，这些二叉树构成的集合记为F；
* 从F中选出两棵根结点权值最小的树（假设为a、b）作为左右子树，构造一棵新二叉树（假设为c），新二叉树的根结点权值为左、右子树根结点权值之和；
* 从F中删除a、b，加入构造出来的新树c；
* 重复（2）（3）两步，直到F中只剩下一棵树为止，这棵树就是霍夫曼树。

示例如下：

* <img src="https://i.loli.net/2021/04/12/uZ84gkrmCvh7EeF.png" style="zoom: 67%;" />
* <img src="https://i.loli.net/2021/04/12/3KDHebMGUoqRtJi.png" style="zoom:67%;" />
* <img src="https://i.loli.net/2021/04/12/1I4zJOQXNKkUu2p.png" style="zoom: 67%;" />
* <img src="https://i.loli.net/2021/04/12/pz7gxjZv1NdhewE.png" style="zoom: 67%;" />

构造结束后，计算其WPL=7×1+5×2+2×3+4×3=35。这在这4个结点**作为叶子结点**所能构成的二叉树中，霍夫曼树的WPL最小。

==总结霍夫曼树的特点：==

* ==权值越大的结点，距离根结点越近；==
* ==树中没有度为1的结点。这类树又叫做**正则（严格）**二叉树；==
* ==树的带权路径长度最短；==

##### 6.3 霍夫曼编码

​	霍夫曼树可以实现**对包含同一内容的文件**找到最节省空间的存储方法，常见的**.zip**压缩文件和**.jpeg**图片文件的底层技术都用到了霍夫曼编码；

​	以下面这个例子来说明霍夫曼树是如何实现对文件进行压缩存储的。现有一个字符串：S=AAABBAACCCDEEA 。

​	选三位长度二进制为各字符编码，编码规则如下：

![](https://i.loli.net/2021/04/12/Ff3eQyprT4MmIqa.png)

根据规则，可以将该字符串编码为：
$$
T(S)=0000000000010010000000100100100111001000000
$$
T(S)的长度为39。显然，这样的编码方式并不是最高效的。



接下来采用霍夫曼树来构造霍夫曼编码：

* 先统计每个字符在字符串中的出现次数

  ![](https://i.loli.net/2021/04/12/i593fY1htvVKlMm.png)

* 将出现次数作为权重，构建霍夫曼树；

  <img src="https://i.loli.net/2021/04/12/xIFhRLH9KJyTwSe.png" style="zoom:67%;" />

* 将每个结点按照分支来编号，左0右1，则从根到每个结点的路径上的数字序列即为每个字符的编码

  ![](https://i.loli.net/2021/04/12/chkz2JKpirvTEZY.png)

* 则对应的S串编码为：
  $$
  H(S)=000110110001010101110111111110
  $$
  此时H(S)的长度为29，比T(S)串短了很多。



​	在解码过程中，采用**前缀码**来解决解码过程中编码歧义的问题，**任一字符的编码串都不是另一个字符编码串的前缀**，由于被编码的字符都处于叶子结点上，而通往任意叶子结点的路径都不可能是通往其余叶子结点路径的子路径，因此任一编码串不可能是其他编码串的子串。

​	对H(S)的解码需要用到编码时构建的霍夫曼树，从根结点按照编码串往下走，直到走到叶子结点即完成对一个字符的解码，再回到根结点循环这个过程，直到把所有字符都解码出来；

使用霍夫曼编码的主要原因还是因为：**霍夫曼编码产生的是最短的前缀码。**

当然，对于同一组结点，霍夫曼树可能不是唯一的，这其中主要有两个影响因素：

* 对相同权值的结点选择顺序不同；
* 调换左右子树的位置也会使得编码结果不同；（考研题目中霍夫曼树左子树的根权值都是小于右子树的根权值，两个权值相同时子树较矮的在左边，答题时尽量按照这一规则去答）

##### 6.4 霍夫曼n叉树

​	霍夫曼二叉树树霍夫曼n叉树的特例，对于结点数目大于等于2的待处理序列，都可以构造霍夫曼二叉树，但==不一定能构造霍夫曼n叉树==，当发现无法构造时，需要补上权值为0的结点让整个序列凑成可以构造霍夫曼n叉树的序列。

​	如：A(1)、B(3)、C(4)、D(6)，就不能直接构造霍夫曼三叉树，需要补上一个权值为0的结点H(0)。

![](/Users/suneann/Library/Application Support/typora-user-images/截屏2021-04-12 下午5.39.50.png)

构造方法如下：

* 选取当前权值较小的三个结点H、A、B构造一棵三叉树T，根结点的权值为4；
* 选取结点C、D和上一步的生成树T的根结点，构造一棵三叉树，根结点权值为14，即为结果霍夫曼三叉树；

$$
WPL=0×2+1×2+3×2+4+6=18
$$

可以发现H结点的存在对WPL值没有影响。

> 在考研数据结构中，要根据具体情况来判断考察的是霍夫曼二叉树还是多叉树，在没有明确指出情况下，一般按照霍夫曼二叉树来处理。

