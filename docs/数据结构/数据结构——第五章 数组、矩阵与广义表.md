# 数据结构——第五章 数组、矩阵与广义表

### 1.数组	

​	在考研中常用的两种数组的逻辑表示：

* 一维数组：
  $$
  (a_0,a_1,...,a_{n-1})
  $$

* 二维数组：
  $$
  [(a_{0,0},a_{0,1},...,a_{0,n-1}),
  (a_{1,0},a_{1,1},...,a_{1,n-1}),
  (a_{2,0},a_{2,1},...,a_{2,n-1}),
  ...,
  (a_{n-1,0},a_{n-1,1},...,a_{n-1,n-1})]
  $$
  ​	数组一般采取顺序存储，在考研中一般涉及最多的就是数组元素下标的计算问题。

  ​	相较于一维数组，二维数组还要考虑**行优先**和**列优先**两种情况。

  

  ##### 1.二维数组的行优先和列优先存储：

  ​	定义二维数组a :`int a[4][5]`。

  * 行优先：

    <img src="https://i.loli.net/2021/04/06/yMAohbI3v8UVDjc.png" style="zoom:50%;" />

    ​	a\[2][3]的求法为：行标2之前的行已经填满元素，每行元素有5个，行标2所指行元素用列标指示出来，因此a\[2][3]是第2×5+3+1=14个元素。

  * 列优先：

    <img src="https://i.loli.net/2021/04/06/TCNfpm7PkGdSh1L.png" style="zoom:50%;" />

    ​	a\[2][3]的求法为：列标3之前的行已经填满元素，每行元素有4个，行标2所指行元素用列标指示出来，因此a\[2][3]是第3×4+2+1=15个元素。

【例】设二维数组A\[6][10],每个数组元素占4个存储单元，若按<u>行优先</u>顺序存放的数组元素A\[3][5]的存储地址是1000，求A\[0][0]的存储地址。



【分析】计算它前面共存放了多少个元素。
$$
3×10+5=35
$$
A\[3][5]的起始地址是1000，所以A\[0][0]的存储地址为：
$$
1000-35×4=860
$$

### 2.矩阵的压缩存储

<img src="https://i.loli.net/2021/04/06/Sk7mz4sEKD28OFq.png" style="zoom:50%;" />

> 注：
>
> ​	考研中出现矩阵第一个元素为$a_{0,0}$,有的为$a_{1,1}$，所以做题时要注意区分。
>
> ​	而考题中存放在C语言二维数组中的矩阵，第一个元素一定是a\[0][0]。



### 3.数组的基本运算

##### 1.二维数组的定义

​	$A_{mn}$即为一个矩阵的逻辑表示。在C语言中，可以用一个二维数组来存储（假设元素类型为整型）：

```c++
int A[m][n];
```

​	其中的`m`与`n`必须为常量，或者预先定义的宏常量。完整定义如下：

```c++
#define m 4
#define n 5
int A[m][n];
```



下边以二维数组为例，讨论数组的基本运算。

##### 2.矩阵的相加

​	两个尺寸均为`m×n`的矩阵相加后得到的依旧是一个尺寸为`m×n`的矩阵，相加规则为$c_{i,j}=a_{i,j}+b_{i,j}$。其中，$c_{i,j}$为结果矩阵$C$中的元素,$a_{i,j}$和$b_{i,j}$为操作数矩阵$A$和$B$中的元素，矩阵的相加即为两矩阵对应位置上的元素逐一相加。

代码如下：

```c++
void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m,int n)
{
  for(int i=0;i<m;++i)
    for(int j=0;i<n;++j)
      C[i][j]=A[i][j]+B[i][j];
}
```

##### 3.矩阵的相乘

​	假设两个矩阵$A$与$B$相乘，结果为$C$,$C$中的第$i$行和第$j$列上的元素为$A$中第i行元素与$B$中第$j$列的元素对应相乘并且求和结果（两向量的点乘）。

​	$A$与$B$相乘的条件是，$A$的列数必须等于$B$的行数。其中$A$的尺寸为$m×n$,$B$的尺寸为$n×k$。

```c++
void mutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m,int n,int k)
{
  for(int i=0;i<m;i++)
    for(int j=0;j<k,j++)
    {
      C[i][j]=0;
      for(int h=0;h<n;++h)
        C[i][j]+=A[i][h]*B[h][j];
    }
}
```

### 4.特殊矩阵

​	这里主要介绍三种常见特殊矩阵。

##### 1.对称矩阵

矩阵中的元素满足$a_{i,j}=a_{j,i}$的矩阵称为对称矩阵。

【例】假设有一个n×n的对称矩阵，第一个元素为$a_{0,0}$,请用一种存储效率较高的存储方式其存储在一维数组中。

【分析】

​	由对称矩阵$a_{i,j}=a_{j,i}$的性质可知其主对角线上下方元素对称相等，所以相同元素只需保存一份即可，所需的存储空间为$(1+n)×n/2$个。需要保存元素为：

<img src="https://i.loli.net/2021/04/06/Yln82F9VNxUJAOB.png" style="zoom:50%;" />

​	按照行优先来存储，保存在一维数组结果为：

![](https://i.loli.net/2021/04/06/6m3VKkrHl58vBdT.png)

这里有几个关键位置的元素下标必须计算出来：

* 第一个元素$a_{0,0}$的下标，显然为0；
* 左下角元素$a_{n-1,0}$，因为其上方有n-1行，每行元素个数构成等差数列，所以总个数为$(n-1)×n/2$个元素，因此$a_{n-1,0}$是第$(n-1)×n/2$个元素；又因为第k个元素在一维数组中的下标为$k-1$,所以$a_{n-1,0}$的下标为$(n-1)×n/2$。
* 右下角元素$a_{n-1,n-1}$，用(2)中类似的方法可算出为$(1+n)×n/2-1$。

##### 2.三角矩阵

​	上三角阵为矩阵下三角部分（不包括对角线）元素全为c(c可为0)的矩阵；

​	下三角阵为矩阵上三角部分（不包括对角线）元素全为c(c可为0)的矩阵。



其存储方式与对称矩阵类似：

![](https://i.loli.net/2021/04/06/y2vdM7GzkxpB4nw.png)

其结果仅仅比上【例】多了一列，用于存储另一部三角分的元素。

##### 3.对角矩阵

<img src="https://i.loli.net/2021/04/06/KszAO5GbCF81Sl2.png" alt="截屏2021-04-06 下午3.40.45" style="zoom:50%;" />

​	上图所视为一个三对角矩阵，求出第i行带状区域的第一个元素在一维数组中的下标，假设c存在数组最后一位。

* 当i等于1时，带状区域内的第一个元素为矩阵中的第一个元素，其在一维数组中的下标为0；
* 当i大于1时，第i行之前的元素个数为$2+(i-2)×3$,则带状区域的第一个元素在一维数组中的下标为$2+(i-2)×3$；

### 5.稀疏矩阵

​	稀疏矩阵中相同元素c(假设c为0)在矩阵中的分布不像在特殊矩阵中那么有规律可循，因此必须为其设计一些特殊的存储结构。

##### 1.顺序存储

常用的存储方法有三元组表示法和伪地址表示法。

* 三元组表示法

  ​	三元组数据结构为一个长度为n，表内每个元素都有3个分量的线性表，其3个分量分别为值、行下标和列下标。结构如下

  ```c++
  typedef struct
  {
    int val;
    int i,j;
  }Trimat;
  
  Trimat trimat[maxterms+1];//定义一个含有maxterms个非零元素的稀疏矩阵
  ```

  ​	语句`trimat[k].val`表示取第k个非0元素值；`trima[k].i`和`trima[k].j`表示取第k个非零元素在矩阵中行下标和列下标，

  ​	当然简单起见，可直接定义一个数组：

  ```c++
  int trimat[maxterms+1][3];
  /*
  trimat[k][0]：表示原矩阵中元素按行优先顺序的第k个非零元素值。
  trimat[k][1]与trimat[k][2]：表示第k个非零元素在矩阵中的位置。
  */
  ```

  一般规定第0行的3个元素分别用来存储非零元素的个数、行数和列数。例如，trimat\[0][0]为原矩阵中非零元素个数，trimat\[0][1]和trimat\[0][2]为矩阵的行列数。

  <img src="https://i.loli.net/2021/04/06/xkM5CuHZ9gQ4ije.png" alt="截屏2021-04-06 下午4.40.39" style="zoom:50%;" />

  当将矩阵定义为float型时，则会带来一个问题：非零元素在矩阵中的行号和列号也被定义成了float型。所以严格来说，取前非零元素在矩阵中的位置时，应该写成如下语句：

  ```c++
  float trimat[maxterms+1][3];
  
  (int) trima[k][1];
  (int) trima[k][2];
  ```

 

【例】给定一个稀疏矩阵A(float型)，其尺寸为$m×n$,建立其对应的三元组存储，并通过三元组打印输出矩阵$A$。

```c++
/*建立三元组B*/
void createtrimat(float A[][maxSize],int m,int n,float B[][3])
{
  int k=1;
  for(int i=0;i<m;i++)
    for(int j=0;j<n;j++)
      if(A[i][j]!=0)
      {
        B[k][0]=A[i][j];
        B[k][1]=i;
        B[k][2]=j;
        ++k;
      }
  B[0][0]=k-1;
  B[0][1]=m;
  B[0][2]=n;
}

/*通过三元组打印矩阵A*/
void print(float B[][3])
{
  int k=1;
  for(int i=0;i<B[0][1];i++)
  {
    for(int j=0;j<B[0][2];j++)
    {
      if(i==(int)B[k][1]&&j==(int)B[k][2])
      {
        cout<<B[k][0]<<"\t";
        k++;
      }
      else
      {
        cout<<"0"<<"\t";
      } 
      cout<<endl;
    }
  }    
}

int main()
{
  ...
  createtrimat(A,5,4,B);//A为5×4矩阵
  print(B);
  ...
}
```

* 伪地址表示法

  ​	伪地址即元素在矩阵中按照行优先或者列优先存储相对位置。用伪地址方法存储稀疏矩阵和三元组方法相似。

  ​	只是，三元组每一行中有两个存储单元存放地址，而伪地址法只需要一个，因此伪地址每一行只有两个存储单元，一个用来存放矩阵元素，另一个用来存放伪地址。

  ​	这种方法需要2N个存储单元，N为非零元素个数。对于一个*m×n*的稀疏矩阵A，元素A\[i][j]的伪地址计算方法为$n(i-1)+j$。根据这个公式，不仅能计算元素中给定元素的伪地址，还能反推原矩阵的真实地址。

##### 2.链式表表示法

* 邻接表表示法

​	邻接表表示法将矩阵中每一行的非零元素串成一个链表，链表结点中有两个分量，分别表示该结点对应的元素值及其列号。

![](https://i.loli.net/2021/04/07/5PHeiMSBXGs7rcY.png)

这种结构设计是出于对一种节约空间的考量。

* 十字邻接表法

​     在稀疏矩阵的十字邻接表存储结构中，矩阵的每一行用一个带头结点的链表表示，每一列也用一个带头结点的链表表示，这种存储结构中的链表结点都有5个分量：行分量、列分量、数据域分量、指针下方结点的指针、指针右方结点的指针：

![](https://i.loli.net/2021/04/07/SGzJtR8PHiUpevW.png)

​	最左边和最上边是头结点数组，不存储数据信息，左上角的结点可以视为整个十字链表的头结点，它有5个分量，分别存储矩阵的行数、列数、非零元素个数以及两个头结点数组指针。

​	十字链表结点中除头结点以外的结点就是存储矩阵非零元素相关信息的普通结点。

###### 2.1 十字链表的定义

(1) 普通结点结构定义

```c++
typedef struct OLNode
{
  int row,col; //行号和列号	
  struct OLNode *right,*down; //指向右边结点和下方结点指针
  float val;
}OLNode;
```

(2)头结点结构定义

```c++
typedef struct
{
  OLNode *rhead,*chead; //指向两头结点数组指针
  int m,n,k; //矩阵函数行数、列数指针
}CrossList;
```

###### 2.2 稀疏矩阵的创建

​	给定一个稀疏矩阵A，其尺寸为$m×n$,非零元素个数为k，建立其对应的十字链表存储结构。

```c++
int createcrossListmat(float A[][maxsize],int m,int n,int k,CrossList &M)
{
  if(M.rhead)
    free(M.rhead);
  if(M.chead)
    free(M.chead);
  M.m=m;
  M.n=n;
  M.k=k;
  //申请头结点数组空间
  if(!(M.chead=(OLNode*)malloc(sizeof(OLNode)*m)))
    return 0;
  if(!(M.rhead=(OLNode*)malloc(sizeof(OLNode)*n)))
    return 0;
  //头结点数组right和down指针置空
  for(int i=0;i<m;++i)
  {
    M.chead[i].right=NULL;
    M.chead[i].down=NULL;
  }
  for(int i=0;i<m;++i)
  {
    M.rhead[i].right=NULL;
    M.rhead[i].down=NULL;
  }
  //建立列链表的辅助指针数组
  OLNode*temps[maxsize];	
  for(int j=0;j<n;++j)
    temps[j]=&(M.rhead[j]);
  //创建十字链表
  for(int i=0;i<m;++i)
  {
    OLNode *r=&(M.chead[i]);
    for(int j=0;j<n;++j)
    {
      if(A[i][j]!=0)
      {
        OLNode *p=(OLNode*)malloc(sizeof(OLNode));
        p->row=i;
        p->col=j;
        p->val=A[i][j];
        p->down=NULL;
        p->right=NULL;
        
        r->right=p;
        r=p;
        temps[j]->down=p;
        temps[j]=p;
      }
    }
  }
  return 1;
}
```

### 6.广义表

##### 1.基本概念

**广义表**：表元素可以是原子或者广义表的一种线性扩展结构。

下面列举一些广义表的例子：

* A=()	A是一个空表，长度为0，深度为1；
* B=(d,e)   B的元素全是原子，即d和e，长度为2，深度为1；
* C=(b,(c,d))    C有两个元素，分别是原子b和另一个广义表(c,d),长度为2，深度为2；
* D=(B,C)       D的元素全是广义表，即B和C，长度为2，深度为3，由此可见，一个广义表可以是递归定义的；
* E=(a,E)       E有两个元素，a及其本身，长度为2，展开E可以得到(a,(a,(a,(a,...)))),是一个无限深的广义表；



**广义表的长度：**为表中最上层元素个数；

**广义表的深度：**为表中括号的最大层数。

**表头（Head）和表尾（Tail）：**当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾。



##### 2.存储结构

**头尾链表存储结构：**

![](https://i.loli.net/2021/04/07/3FrT8XAVNpftaHi.png)

​	上图展示了广义表头尾链表存储结构的存储情况，其中有两种结点，即原子结点和广义表结点。

* 原子结点有两个域：标记域和数据域；
* 广义表结点有三个域：标记域、头指针域和尾指针域；
* 标记域：0表示原子节点，1表示广义表；

**扩展线性结构：**

![](https://i.loli.net/2021/04/07/4tJEU5r3ap2M1wT.png)

其中也有两个结点，即原子结点和广义表结点。

* 原子结点有3个域：标记域、数据域、尾指针域；
* 广义表也有3个域：标记域、头指针域和尾指针域；
* 同样，标记域中0表示原子节点，1表示广义表；