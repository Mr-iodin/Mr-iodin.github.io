# 数据结构——第七章 图

### 1.图的基本概念

​	`图`：由结点的有穷集合V和边的集合E组成。为了和树形结构区别，在图的结构中常常把结点称为顶点，边是顶点的有序偶对。

​	`有向图和无向图`：

<img src="https://i.loli.net/2021/04/13/uLCAE6YsTyRQrSG.png" style="zoom:50%;" />

​	`弧`：在有向图中，通常把边称为弧，含箭头的一端称为弧头，另一端称为弧尾，记作<v<sub>i</sub>,v<sub>j</sub>>。

​	`顶点点度、入度和出度`：在无向图中，边记为（v<sub>i</sub>,v<sub>j</sub>),它等价于在有向图中存在<v<sub>i</sub>,v<sub>j</sub>>和<v<sub>j</sub>,v<sub>i</sub>>两条边。与顶点v相关的边的条数称为顶点v点度。指向顶点v的边的条数称为顶点v的入度，由顶点v发出的边的条数称为顶点v的出度。

​	`有向完全图和无向完全图`：若有向图有n个顶点，则最多有n(n-1)条边，将具有n(n-1)条边的有向图称为有向完全图。

​	`路径和路径长度`：在一个图中，路径为相邻顶点序偶所构成的序列。路径长度是指路径上边的数目（如在a)中，<C,B>、<B、A>是一条路径，路径长度为2）。

​	`简单路径`:序列中顶点不重复出现的路径称为简单路径。

​	`回路`：若一条路径中第一个顶点和最后一个顶点相同，那么这条路是一条回路；

​	`连通、连通图和连通分量`：在无向图中，若从顶点v<sub>i</sub>到顶点v<sub>j</sub>有路径，则称v<sub>i</sub>和v<sub>j</sub>连通。如果图中任意两个顶点之间都连通，则称该图为连通图；否则，图中极大连通子图称为连通分量。

​	`强连通图和强连通分量`：在有向图中，若从v<sub>i</sub>到v<sub>j</sub>有路径，则称从v<sub>i</sub>到v<sub>j</sub>是连通的。如果对于每一对顶点v<sub>i</sub>和v<sub>j</sub>，从v<sub>i</sub>到v<sub>j</sub>和从v<sub>j</sub>到v<sub>i</sub>都有路径，则称该图为强连通图；否则，将其中的极大强连通子图称为强连通分量。

​	`权和网`：图中每条边都可以附有一个对应的树，这种与边相关的树称为权。权可以表示从一个顶点到另外一个顶点的距离或者花费最小的代价。边上带有权的图称为带权图，也称为网；

​	

> 对极大连通子图的中“极大”的理解：
>
> ​	“极大”通俗理解就是不能再大，以下面两个图为例子：
>
> ![](https://i.loli.net/2021/04/13/DtN3YGKx52heCO6.png)
>
> 在上图中，A—B是一个连通子图，但不是极大连通子图，因为它还可以再扩一个顶点C。同理，D—E—F也是一个连通子图，但不是极大连通子图，因为还可以扩充到另一个顶点G。
>
> 因此，A—B—C和D—E—F—G这两个子图才是极大连通子图。
>
> 综上所述：
>
> ​	一个图中的极大连通子图可以这样得到：从一个顶点开始作为一个子图，逐个添加和这个子图有边相连的顶点，直到所有先连的顶点都被纳入图中，所生成的子图就是一个极大连通子图。

### 2.邻接矩阵与邻接表

​	邻接矩阵是表示顶点之间相邻关系的矩阵。设G=(V,E)是具有n个顶点的图，顶点的序号依次为0，1，...，n-1，则G的邻接矩阵是具有如下定义的n阶方阵A：

* A\[i][j]=1表示顶点i与顶点j邻接，即i与j之间存在边或者弧；
* A\[i][j]=0表示顶点i与顶点j不邻接(0<=i,j<=n-1);

​    邻接矩阵是图的**顺序存储结构**，由邻接矩阵的行数或列数可知图中的顶点数。

下图为无权与有权邻接矩阵的表示：

![](https://i.loli.net/2021/04/14/GoRmWOZUslguXqn.png)

> 说明：
>
> ​	对于有权图的存储，不同的书对某顶点到其自身的路径长度有不同的规定，有点规定为0，表示自己到自己的距离为0；有的规定为无穷大，表示自己到自己没有路径。



##### 2.1 邻接矩阵

邻接矩阵的定义如下:

```c++
typedef struct
{
  int no;	//顶点编号
  char info;	//顶点其他信息
}VertexType;	//顶点类型

typedef struct	//图的定义
{
  int edges[maxSize][maxSize];
  int n,e;	//顶点数和边数
  VertexType vex[maxSize];	//结点信息
}MGraph;	//图的邻接矩阵类型；
```

> 说明：邻接矩阵的定义在考研中的用法为以下两种情况
>
> * 如果题目说明图采用邻接矩阵表示，并且要求写出邻接矩阵的定义，则需要将上述代码全部写出；
>
> * 如果题目没有要求写出其定义，只是说图用邻接矩阵表示，此时不需要写出以上代码，但是在解题中要引用结构体各成员，下面以一个函数为例说明其用法：
>
>   ```c++
>   void f(MGraph G)
>   {
>     int a=G.n;
>     int b=G.e;
>     ...
>   }
>   ```
>



##### 2.2 邻接表

​	邻接表的图的一种链式存储结构。所谓邻接表就是对图中每一个顶点i建立一个单链表，每个单链表的第一个结点存放有关顶点信息。

​	所以邻接表由单链表的表头形成结点的表和单链表其余结点形成的边表两个部分组成。一般顶点表存放顶点信息和指向第一个边的结点指针，边表结点存放于当前顶点相邻顶点的序号和指向下一个边结点的指针。

​	邻接表存储表示的定义如下：

```c++
typedef struct ArcNode
{
  int adjvex;	//该边指向的结点位置
  struct ArcNode *nextarc;	//指向下一条边的指针
  int info;//边的相关信息，如权重
}ArcNode;

typedef struct
{
  char data;	//顶点信息
  ArcNode *firstarc;	//指向第一条边的指针
}VNode;

typedef struct
{
  VNode adjlist[maxSize];//邻接表
  int n,e;	//顶点数和边数
}AGraph;
```

结合下图理解：

![](https://i.loli.net/2021/04/14/TYgKLRomU5Erph3.png)



==以上两种存储结构的定义，一定要熟练的默写下来。==

##### 2.3 邻接多重表

​	和十字链表类似，是由顶点表和边表组成的，每一条边用一个顶点表，其顶点表结点结构和边表结点结构如下图：

![](https://i.loli.net/2021/04/14/IHKYQ618FPeGqVv.png)

​	其中，顶点表由两个域组成：

* vertex域存储和该顶点相关的信息；
* firstedge域指示第一条附属于该顶点的边；
* 边表结点由6个域组成；
* mark为标记域，用于标记该条边是否被搜索过；
* ivex和jvex为该边依附的两个顶点在 图中的位置；
* ilink指向下一条依附于顶点ivex的边；
* jlink指向下一条依附于顶点jvex的边；
* info为指向与边相关的各种信息的指针域。

![](https://i.loli.net/2021/04/14/5mSfoUqni9pB1Pb.png)

### 3.图的遍历

##### 3.1 深度优先搜索遍历

​	图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。它的基本思想如下：

* 首先访问出发地v，并将其标记为已访问过；
* 然后选取与v邻接的未被访问的任意顶点w，并访问它；
* 再选取w邻接的未被访问的任意一顶点并访问，以此重复进行。
* 当一顶点所有邻接顶点都被访问过时，则依次退回到最近被访问过的顶点，该顶点还有其他邻接顶点未被访问，则从这些未被访问的顶点中取一个并重复上述访问过程，直到图中的所有结点都被访问过为止。

![](https://i.loli.net/2021/04/14/GozxAY2X6VeysTZ.png)

总结算法执行过程：**仍取一个顶点，访问之，然后检查这个顶点点所有邻接顶点，递归访问其中未被访问过的顶点。**

```c++
int visit[maxSize];

void DFS(AGraph *G,int v)
{
  AGraph *p;
  visit[v]=1;
  Visit(v);
  p=G->adjlist[v].first;//p指向顶点v的第一条边
  while(p!=NULL)
  {
    if(visit[p->adjvex]==0)
      DFS(G,p-adjvex)
    p=p->nextarc;  
  }
}
```

##### 3.2 广度优先搜索遍历

​	图的广度优先类似于树的层次遍历。它的基本思想是：

* 首先访问起始顶点v；
* 然后选取与v邻接的全部顶点w<sub>1</sub>,...,w<sub>n</sub>进行访问；
* 再依次访问与w<sub>1</sub>,...,w邻接的全部顶点（已经访问的除外），以此类推，直到所有顶点都被访问过为止。

算法执行过程简单概括如下：

* 任取图中一个顶点访问，入队，并将这个顶点标记为已访问；
* 当队列不空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队。
* 当队列为空时跳出循环，广度优先搜索即完成；

```c++
void BFS(AGraph *G,int v,int visit[maxSize])
//visit[]数组被初始化为全0
{
  ArcNode *p;
  int que[maxSize],front=0,rear=0;
  int j;
  Visit(v);
  visit[v]=1;
  rear=(rear+1)%maxSize;
  que[rear]=v;
  while(front!=rear)
  {
    front=(front+1)%maxSize;
    j=que[front];
    p=G->adjlist[j].fristarc;
    while(p!=NULL)
    {
      if(visit[p->adjvex]==0)
      {
        Visit(p->adjvex);
        visit[p->adjvex]=1;
        rear=(rear+1)%maxSize;//该顶点进队
        que[rear]=p->adjvex;
      }
      p=p->nextarc;	//p指向j的下一条边
    }
  }
}
```

​	以上两种遍历方法是针对连通图。对非连通图进行遍历，只需将上述遍历函数放在一个循环中，循环用来检测图中的每一个顶点，如果当前顶点没有访问，则调用上述函数从这个顶点遍历，否则什么也不做。

* 深度优先搜索遍历

```c++
void dfs(AGraph *g)
{
  int i;
  fot(i=0;i<g->n;++i)
    if(visit[i]==0)
      DFS(g,i);
}
```

* 广度优先搜索遍历

```c++
void bfs(AGraph *g)
{
  int i;
  for(i=0;i<g->n;++i)
    if(visit[i]==0)
      BFS(g,i,visit);
}
```

> ​	图的遍历是本章一切操作的基础，也是考研重中之重。