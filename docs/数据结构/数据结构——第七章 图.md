# 数据结构——第七章 图

### 1.图的基本概念

​	`图`：由结点的有穷集合V和边的集合E组成。为了和树形结构区别，在图的结构中常常把结点称为顶点，边是顶点的有序偶对。

​	`有向图和无向图`：

<img src="https://i.loli.net/2021/04/13/uLCAE6YsTyRQrSG.png" style="zoom:50%;" />

​	`弧`：在有向图中，通常把边称为弧，含箭头的一端称为弧头，另一端称为弧尾，记作<v<sub>i</sub>,v<sub>j</sub>>。

​	`顶点点度、入度和出度`：在无向图中，边记为（v<sub>i</sub>,v<sub>j</sub>),它等价于在有向图中存在<v<sub>i</sub>,v<sub>j</sub>>和<v<sub>j</sub>,v<sub>i</sub>>两条边。与顶点v相关的边的条数称为顶点v点度。指向顶点v的边的条数称为顶点v的入度，由顶点v发出的边的条数称为顶点v的出度。

​	`有向完全图和无向完全图`：若有向图有n个顶点，则最多有n(n-1)条边，将具有n(n-1)条边的有向图称为有向完全图。

​	`路径和路径长度`：在一个图中，路径为相邻顶点序偶所构成的序列。路径长度是指路径上边的数目（如在a)中，<C,B>、<B、A>是一条路径，路径长度为2）。

​	`简单路径`:序列中顶点不重复出现的路径称为简单路径。

​	`回路`：若一条路径中第一个顶点和最后一个顶点相同，那么这条路是一条回路；

​	`连通、连通图和连通分量`：在无向图中，若从顶点v<sub>i</sub>到顶点v<sub>j</sub>有路径，则称v<sub>i</sub>和v<sub>j</sub>连通。如果图中任意两个顶点之间都连通，则称该图为连通图；否则，图中极大连通子图称为连通分量。

​	`强连通图和强连通分量`：在有向图中，若从v<sub>i</sub>到v<sub>j</sub>有路径，则称从v<sub>i</sub>到v<sub>j</sub>是连通的。如果对于每一对顶点v<sub>i</sub>和v<sub>j</sub>，从v<sub>i</sub>到v<sub>j</sub>和从v<sub>j</sub>到v<sub>i</sub>都有路径，则称该图为强连通图；否则，将其中的极大强连通子图称为强连通分量。

​	`权和网`：图中每条边都可以附有一个对应的树，这种与边相关的树称为权。权可以表示从一个顶点到另外一个顶点的距离或者花费最小的代价。边上带有权的图称为带权图，也称为网；

​	

> 对极大连通子图的中“极大”的理解：
>
> ​	“极大”通俗理解就是不能再大，以下面两个图为例子：
>
> ![](https://i.loli.net/2021/04/13/DtN3YGKx52heCO6.png)
>
> 在上图中，A—B是一个连通子图，但不是极大连通子图，因为它还可以再扩一个顶点C。同理，D—E—F也是一个连通子图，但不是极大连通子图，因为还可以扩充到另一个顶点G。
>
> 因此，A—B—C和D—E—F—G这两个子图才是极大连通子图。
>
> 综上所述：
>
> ​	一个图中的极大连通子图可以这样得到：从一个顶点开始作为一个子图，逐个添加和这个子图有边相连的顶点，直到所有先连的顶点都被纳入图中，所生成的子图就是一个极大连通子图。

### 2.邻接矩阵与邻接表

​	邻接矩阵是表示顶点之间相邻关系的矩阵。设G=(V,E)是具有n个顶点的图，顶点的序号依次为0，1，...，n-1，则G的邻接矩阵是具有如下定义的n阶方阵A：

* A\[i][j]=1表示顶点i与顶点j邻接，即i与j之间存在边或者弧；
* A\[i][j]=0表示顶点i与顶点j不邻接(0<=i,j<=n-1);

​    邻接矩阵是图的**顺序存储结构**，由邻接矩阵的行数或列数可知图中的顶点数。

下图为无权与有权邻接矩阵的表示：

![](https://i.loli.net/2021/04/14/GoRmWOZUslguXqn.png)

> 说明：
>
> ​	对于有权图的存储，不同的书对某顶点到其自身的路径长度有不同的规定，有点规定为0，表示自己到自己的距离为0；有的规定为无穷大，表示自己到自己没有路径。



##### 2.1 邻接矩阵

邻接矩阵的定义如下:

```c++
typedef struct
{
  int no;	//顶点编号
  char info;	//顶点其他信息
}VertexType;	//顶点类型

typedef struct	//图的定义
{
  int edges[maxSize][maxSize];
  int n,e;	//顶点数和边数
  VertexType vex[maxSize];	//结点信息
}MGraph;	//图的邻接矩阵类型；
```

> 说明：邻接矩阵的定义在考研中的用法为以下两种情况
>
> * 如果题目说明图采用邻接矩阵表示，并且要求写出邻接矩阵的定义，则需要将上述代码全部写出；
>
> * 如果题目没有要求写出其定义，只是说图用邻接矩阵表示，此时不需要写出以上代码，但是在解题中要引用结构体各成员，下面以一个函数为例说明其用法：
>
>   ```c++
>   void f(MGraph G)
>   {
>     int a=G.n;
>     int b=G.e;
>     ...
>   }
>   ```



##### 2.2 邻接表

​	邻接表的图的一种链式存储结构。所谓邻接表就是对图中每一个顶点i建立一个单链表，每个单链表的第一个结点存放有关顶点信息。

​	所以邻接表由单链表的表头形成结点的表和单链表其余结点形成的边表两个部分组成。一般顶点表存放顶点信息和指向第一个边的结点指针，边表结点存放于当前顶点相邻顶点的序号和指向下一个边结点的指针。

​	邻接表存储表示的定义如下：

```c++
typedef struct ArcNode
{
  int adjvex;	//该边指向的结点位置
  struct ArcNode *nextarc;	//指向下一条边的指针
  int info;//边的相关信息，如权重
}ArcNode;

typedef struct
{
  char data;	//顶点信息
  ArcNode *firstarc;	//指向第一条边的指针
}VNode;

typedef struct
{
  VNode adjlist[maxSize];//邻接表
  int n,e;	//顶点数和边数
}AGraph;
```

结合下图理解：

![](https://i.loli.net/2021/04/14/TYgKLRomU5Erph3.png)



==以上两种存储结构的定义，一定要熟练的默写下来。==

##### 2.3 邻接多重表

​	和十字链表类似，是由顶点表和边表组成的，每一条边用一个顶点表，其顶点表结点结构和边表结点结构如下图：

![](https://i.loli.net/2021/04/14/IHKYQ618FPeGqVv.png)

​	其中，顶点表由两个域组成：

* vertex域存储和该顶点相关的信息；
* firstedge域指示第一条附属于该顶点的边；
* 边表结点由6个域组成；
* mark为标记域，用于标记该条边是否被搜索过；
* ivex和jvex为该边依附的两个顶点在 图中的位置；
* ilink指向下一条依附于顶点ivex的边；
* jlink指向下一条依附于顶点jvex的边；
* info为指向与边相关的各种信息的指针域。

![](https://i.loli.net/2021/04/28/YaAsgUyM2S7CLGt.png)



### 3.图的遍历

##### 3.1 深度优先搜索遍历

​	图的深度优先搜索遍历（DFS）类似于二叉树的先序遍历。它的基本思想如下：

* 首先访问出发地v，并将其标记为已访问过；
* 然后选取与v邻接的未被访问的任意顶点w，并访问它；
* 再选取w邻接的未被访问的任意一顶点并访问，以此重复进行。
* 当一顶点所有邻接顶点都被访问过时，则依次退回到最近被访问过的顶点，该顶点还有其他邻接顶点未被访问，则从这些未被访问的顶点中取一个并重复上述访问过程，直到图中的所有结点都被访问过为止。

![](https://i.loli.net/2021/04/14/GozxAY2X6VeysTZ.png)

总结算法执行过程：**仍取一个顶点，访问之，然后检查这个顶点点所有邻接顶点，递归访问其中未被访问过的顶点。**

```c++
int visit[maxSize];

void DFS(AGraph *G,int v)
{
  AGraph *p;
  visit[v]=1;
  Visit(v);
  p=G->adjlist[v].first;//p指向顶点v的第一条边
  while(p!=NULL)
  {
    if(visit[p->adjvex]==0)
      DFS(G,p->adjvex)
    p=p->nextarc;  
  }
}
```

##### 3.2 广度优先搜索遍历

​	图的广度优先类似于树的层次遍历。它的基本思想是：

* 首先访问起始顶点v；
* 然后选取与v邻接的全部顶点w<sub>1</sub>,...,w<sub>n</sub>进行访问；
* 再依次访问与w<sub>1</sub>,...,w邻接的全部顶点（已经访问的除外），以此类推，直到所有顶点都被访问过为止。

算法执行过程简单概括如下：

* 任取图中一个顶点访问，入队，并将这个顶点标记为已访问；
* 当队列不空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队。
* 当队列为空时跳出循环，广度优先搜索即完成；

```c++
void BFS(AGraph *G,int v,int visit[maxSize])
//visit[]数组被初始化为全0
{
  ArcNode *p;
  int que[maxSize],front=0,rear=0;
  int j;
  Visit(v);
  visit[v]=1;
  rear=(rear+1)%maxSize;
  que[rear]=v;
  while(front!=rear)
  {
    front=(front+1)%maxSize;
    j=que[front];
    p=G->adjlist[j].fristarc;
    while(p!=NULL)
    {
      if(visit[p->adjvex]==0)
      {
        Visit(p->adjvex);
        visit[p->adjvex]=1;
        rear=(rear+1)%maxSize;//该顶点进队
        que[rear]=p->adjvex;
      }
      p=p->nextarc;	//p指向j的下一条边
    }
  }
}
```

​	以上两种遍历方法是针对连通图。对非连通图进行遍历，只需将上述遍历函数放在一个循环中，循环用来检测图中的每一个顶点，如果当前顶点没有访问，则调用上述函数从这个顶点遍历，否则什么也不做。

* 深度优先搜索遍历

```c++
void dfs(AGraph *g)
{
  int i;
  fot(i=0;i<g->n;++i)
    if(visit[i]==0)
      DFS(g,i);
}
```

* 广度优先搜索遍历

```c++
void bfs(AGraph *g)
{
  int i;
  for(i=0;i<g->n;++i)
    if(visit[i]==0)
      BFS(g,i,visit);
}
```

> ​	图的遍历是本章一切操作的基础，也是考研重中之重。

##### 3.3 例题

​	【例一】设计一个算法，求不带权无向连通图G中距离顶点v最远的一个顶点（所谓最远就是到v的路径长度最长）

​	【分析】图的广度优先搜索遍历方式体现了由图中某个顶点开始，以近向远层层扩展的方式遍历图中结点的过程，因此广度优先搜索遍历过程中最后一个顶点一定是距离给定顶点最远的顶点。

因此，只需遍历广度优先算法，返回最后一个顶点即可。

```c++
int BFS(AGraph *G,int v)
{
  ArcNode *p;
  int que[maxSize],front=0,rear=0;
  int visit[maxSize];
  int i,j;
  for(i=0;i<G->n;i++)
    visit[i]=0;
  rear=(rear+1)%maxSize;
  que[rear]=v;
  visit[v]=1;
  while(front!=rear)
  {
    front=(front+1)%maxSize;
    j=que[front];
    p=G->adjlist[j].firstarc;
    while(p!=NULL)
    {
      if(visit[p->adjvex]==0)
      {
        visit[p->adjvex]=1;
        rear=(rear+1)%maxSize;
        que[rear]=p->adjvex;
      }
      p=p->nextarc;
    }
  }
  return j;	//队空时，j保存了遍历过程中的最后一个结点
}
```

> 说明：考试时需要在代码前加一句“假设本题用“邻接表作为图的存储。



【例2】设计一个算法，判断无向图G是否是一棵树，若是就返回1，否则返回0。

【分析】一个无向图的条件是有n-1条边的连通图边和顶点数目是否满足条件可由图信息直接判断，连通与否可由遍历能否访问所有顶点判断。

```c++
void DFS2(AGraph *G,int &vn,int &en)
{
	ArcNode *p;
  visit[v]=1;
  ++vn;
  p=G->adjlist[v].firstarc;
  while(p!=NULL)
  {
    ++en;
    if(visit[p->adjvex]==0)
      DFS2(G,p->adjvex,vn,en);
    p=p->nextarc;
  }
}
int GisTree(AGraph *G)
{
  int vn=0,en=0,i;
  for(i=0;i<G->n;++i)
    visit[i]=0;
  DFS2(G,1,vn,en);
  if(vn==G->n&&(G->n-1)==en/2)
    return 1;
  else return 0;
}
```

> 最后一个if语句中第二个表达式为什么是`（G->n-1）==en/2`:
>
> ​	在每次来到一个新顶点时，en中累加了当前访问顶时到所有边。
>
> <img src="https://i.loli.net/2021/04/15/3NEbfS7DilU9gAo.png" style="zoom:50%;" />
>
> ​	最后en等于10，正好是实际边数到两倍，可见`(G->n-1)==en/2`这种写法是正确的。



【例3】图采用邻接表存储，设计一个算法，判别顶点i和顶点j(i!=j)之间是否有路径。

【分析】从顶点i开始进行一次深度搜索遍历，遍历过程 中遇到j说明i与j之间有路径，否则没有路径。

```c++
int DFSTrave(AGraph *G,int i,int j)
{
  int k;
  for (k=0;k<G->n;++k)
    visit(k)=0;
  DFS(G,i);
  if(visit[j]==1)
    return 1;
  else
    return 0;
}
```

### 4.最小生成树

##### 4.1普里姆算法

​	通过下图介绍带权无向图采用普里姆算法求解最小生成树的过程：

​	<img src="https://i.loli.net/2021/04/15/TqjMoRtJeXkUZuw.png" style="zoom:67%;" />

* 以顶点0为起点，如a)所示，此时候选边的边长分别为5、1和2，最小边长为1；
* 如b)所示，选择边长为1的边，此时候选边长为5、3、2、6和2，其中最小边长为2；
* 如c)所示，选择边长为2的边，候选边长分别为5、3、2、和3，其中最小边长为2；
* 如d)所示，选择边长为2的边，此时候选边长分别为3、4和5，其中最小边长为3；
* 如e)所示，选择边长为3的边，此时所有顶点都已并入生成树，生成树求解完毕。

普里姆算法执行过程：

* 将v<sub>0</sub>到其他顶点的所有边当作候选边；
* 重复以下步骤n-1次，使得其他n-1个顶点被并入到生成树中。
  * 从候选边中挑选出权值最小的边输出，并将与该边另一端相接的顶点v并入生成树中；
  * 考查所有剩余顶点v<sub>i</sub>,如果(v,v<sub>i</sub>)的权值比lowcost[v<sub>i</sub>]小，则用（v,v<sub>i</sub>)的权值更新[v<sub>i</sub>];

```c++
void Prim(MGraph g,int v0,int &sum)
{
  int lowcost[maxSize],vset[maxSize],v;
  int i,j,k,min;
  v=v0;
  for(i=0;i<g.n;i++)
  {
    lowcost[i]=g.edges[v0][i];
    vset[i]=0;
  }
  vset[v0]=1;
  sum=0;
  for(i=0;i<g.n-1;++i)
  {
    min=INF;	//INF定义了一个比图中所有边权值都大的常量
    for(j=0;j<g.n;++j)
      if(vset[j]==0&&lowcost[j]<min)//选择当前生成树到其余顶点最短边中的最短一条
      {
        min=lowcost[j];
        k=j;
      }
    vset[k]=1;
    v=k;
    sum+=min;
    for(j=0;j<g.n;j++)
      if(vset[j]==0&&g.edges[v][j]<lowcost[j])
        lowcost[j]=g.edges[v][j];	//执行过程中的第2）步
  }
}
```

普里姆算法时间复杂度分析：

​	普里姆算法主要部分是一个双重循环，外层循环内有两个并列单层循环，单层循环的操作都是常量级的，因此可以取任意一个单层循环内的操作作为基本操作。总共执行次数为n<sup>n</sup>，因此在邻接矩阵结构下，普里姆算法的时间复杂度为O(n<sup>2</sup>)。

##### 4.2 克鲁斯卡尔算法

​	每次找出候选边中权值最小的边，就将该边并入生成树中。重复此过程直到所有边被检测完为止

![](https://i.loli.net/2021/04/28/lgCFzmfGYvpkeNM.png)

克鲁斯卡尔算法执行过程

​	将图中边按照权值大小从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，若构不成回路，则将该边并入当前生成树中，直到所有边都被检测完为止。

​	判断是否产生回路就要用到**并查集**。并查集中保存了一棵或几棵树，这些树有这样的特点：通过树中一个结点，可以找到其双亲结点，进而找到根结点。

​	这样的特性有两个好处：

* 一是**可以快速将两个含有很多元素的集合并成一个**。两个集合就是并查集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何一个结点的孩子结点即可；
* 二是**可以方便地判断两个元素是否属于同一个集合**。通过两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一集合，否则属于不同集合。

并查集可以用一维数组来简单地表示。

以下是并查集在一维数组中表示及合并过程：

![](https://i.loli.net/2021/04/28/WskOqHBVxG1Pvle.png)

```c++
typedef struct
{
  int a,b;	//a和b为一条边所连的两个顶点
  int w;	//边的权值
}Road;

Road road[maxSize];

int v[maxSize];
int getRoot(int a)//在并查集中查找根结点
{
  while(a!=v[a])	a=v[a];
  
}
void Kruskal(MGraph g,int &sum,Road road[])
{
  int i;
  int N,E,a,b;
  N=g.n;
  E=g.e;
  sum=0;
  for(i=0;i<N;i++) v[i]=i;
  sort(road,E);//对road数组中E条边的权值从小到大排序
  for(i=0;i<E;i++)
  {
    a=getRoot(road[i].a);
    b=getRoot(road[i].b);
    if(a!=b)
    {
      v[a]=b;
      sum+=road[i].w;
    }
  }
  
}
```

> 说明：
>
> ​	上述克鲁斯卡尔算法中函数sort()在考试中要按照题目对算法时间复杂度要求选择合适的排序函数写出。



克鲁斯卡尔算法时间复杂度分析：

​	算法时间复杂度花费在sort()和单层循环上。循环是线性级的，可以认为算法时间主要花在函数sort()上。

​	排序算法处理数据规模又图的边数e决定，与顶点无关，所以**克鲁斯卡尔适用于稀疏图**。	



##### 4.3 例题

【例一】什么样的图其最小生成树是唯一的？

答：在构建最小生成树时，如果图中所有边权值均不相等，那么最小生成树是唯一的。

【例二】已知带权连通图的邻接表如下图所示，

![](https://i.loli.net/2021/05/10/nZdsrNXBevCg8Gm.png)

请画出该图，并且分别以深度优先和广度优先的方法遍历该图，写出遍历中结点的序列，并画出该图G的一棵最小生成树。

解：

<img src="https://i.loli.net/2021/04/28/9Pk2hdr5EMywS74.jpg" style="zoom:50%;" />

从顶点1出发，

* 采用深度优先算法，得到结点的序列为 1、2、3、4、5（从权值最小的边开始走）；
* 采用广度优先算法，得到结点的序列为 1、2、3、4、5；

### 5.迪杰斯特拉算法

##### 5.1 算法基本思想

**算法思想：**

​	设有两个顶点集合S和T，集合S中存放图中已找到最短路径的顶点，集合T存放图中剩余顶点。

* 初始状态时，集合S中包含源点v<sub>0</sub>,然后不断从集合T中选取到顶点v<sub>0</sub>路径长度最短的顶点v<sub>u</sub>并入到集合S中；
* 集合S每并入一个新的顶点v<sub>u</sub>，都要修改顶点v<sub>0</sub>到集合T中顶点的最短路径长度值。

**算法执行过程：**

需要引进3个辅助数组`dist[]`、`path[]`、`set[]`;

* dist[v<sub>i</sub>]表示当前已找到的从v<sub>0</sub>到每个终点v<sub>i</sub>的最短路径长度。

  初态为：若从v<sub>0</sub>到v<sub>i</sub>有边，则dist[v<sub>i</sub>]w为边上的权值，否则置dist[v<sub>i</sub>]为∞；

* path[v<sub>i</sub>]中保存从v<sub>0</sub>到v<sub>i</sub>最短路径上v<sub>i</sub>的前一个顶点，假设最短路径上的顶点序列为v<sub>0</sub>,v<sub>1</sub>,v<sub>2</sub>,...,v<sub>i-1</sub>,v<sub>i</sub>,则path[v<sub>i</sub>]=v<sub>i-1</sub>。

  path[]的初态为：如果v<sub>0</sub>到v<sub>i</sub>有边，则path[v<sub>i</sub>]=v<sub>0</sub>，否则path[v<sub>i</sub>]=-1。

* set[]为标记数组，set[v<sub>i</sub>]=0表示v<sub>i</sub>在T中，即没有并入最短路径；set[v<sub>i</sub>]=1表示v<sub>i</sub>在S中，即已经并入最短路径。

  set[]初态为：set[v<sub>0</sub>]=1,其余元素全为0。

**算法流程如下：**

* 从当前`dist[]`数组中选出最小值，假设dist[v<sub>u</sub>]，将set[v<sub>u</sub>]设置为1，表示当前新并入的顶点为v<sub>u</sub>；

* 循环扫描图中的顶点，对每个顶点进行以下检测：

  假设当前顶点为v<sub>j</sub>，检测v<sub>j</sub>是否已经并入S中，即看是否set[v<sub>j</sub>]=1。如果set[v<sub>j</sub>]=1，则什么都不做；如果set[v<sub>j</sub>]=0，则比较dist[v<sub>j</sub>]和dist[v<sub>u</sub>]+w的大小，其中w为边<v<sub>u</sub>,v<sub>j</sub>>的权值。这个比较就是要看v<sub>0</sub>经过旧的最短路径到达v<sub>j</sub>  和  v<sub>0</sub>经过含有v<sub>u</sub>的新的最短路径到达v<sub>j</sub>哪个更短，若dist[v<sub>j</sub>]>dist[v<sub>u</sub>]+w,则用新的路径长度来更新旧的，并把顶点v<sub>u</sub>加入路径中，且作为路径上v<sub>j</sub>之前的那个顶点，否则什么也不做。

* 对1）和2）循环执行n-1次（n为图中顶点个数），即可得到v<sub>0</sub>到其余顶点的最短路径。

【例】对下图所示的有向图，用迪杰斯特拉算法求从顶点0到其余各顶点最短路径。

<img src="https://i.loli.net/2021/04/30/EJhbGW61sMyNutm.png" style="zoom: 67%;" />

初始状态：

* dist[0]置为0，dist[1]置为4，dist[2]置为6，dist[3]置为6，其余元素置为∞；
* path[1]置为0,path[2]置为0,path[3]置为0,其余置为-1；
* set[0]置1，其余元素置0。

1）从通往当前剩余顶点的路径中选出最短的，是0 ->1，长度为dist[1]=4,因此将顶点1并入最短路径中，set[1]置为1。

<img src="https://i.loli.net/2021/04/30/QnZohWbARSjkXVi.png" style="zoom:67%;" />

以1为中间点检测其余顶点{2,3,4,5,6}：

* dist[2]=6>dist[1]+g[1]\[2]=5,因此dist[2]重制为5，path[2]重制为1；
* dist[3]=6<dist[1]+g[1]\[3]=∞,因此dist[3]不变，path[3]仍为0；
* dist[4]=∞>dist[1]+g[1]\[4]=11,因此dist[4]重制为11，path[4]重制为1；
* dist[5]=∞=dist[1]+g[1]\[5]=∞,因此dist[5]不变，path(5)仍为-1；
* dist[6]=∞=dist[1]+g[1]\[6]=∞,因此dist[6]不变，path(6)仍为-1；

![](https://i.loli.net/2021/04/30/oYaNvFLk5jJIHl2.png)

2）从通往当前剩余顶点的路径中选出长度最短的，是0->1->2,长度为dist[2]=5,因此将顶点2并入最短路径中，set[2]置为1。

<img src="https://i.loli.net/2021/04/30/IeifAzvncda1tN4.png" style="zoom:67%;" />

以2为中心点检测剩余顶点{3,4,5,6}:

* dist[3]=6<dist[2]+g[2]\[3]=∞,因此dist[3]不变，path[3]仍为0；
* dist[4]=11=dist[2]+g[2]\[4]=11,因此dist[4]仍为11不变，path[4]仍为1；
* dist[5]=∞>dist[2]+g[2]\[5]=9,因此dist[5]重制为9，path[5]重制为2；
* dist[6]=∞=dist[2]+g[2]\[6]=∞,因此dist[6]不变，path(6)仍为-1；

![](https://i.loli.net/2021/04/30/8EVKiofZJOgXqhC.png)

3）从通往当前剩余顶点中选取路径长度最短的，是0->3,长度为dist[6],因此将3并入最短路径中，set[3]设为1。

<img src="https://i.loli.net/2021/04/30/lyOr9VmXNAgCin1.png" style="zoom:67%;" />

以3为中心顶点检测剩余顶点{4,5,6}：

* dist[4]=11<dist[3]+g[3]\[4]=∞，因此dist[4]不变，path[4]不变；
* dist[5]=9<dist[3]+g[3]\[5]=11，因此dist[5]不变，path[5]不变；
* dist[6]=∞<dist[3]+g[3]\[6]=∞，因此dist[6]不变，path[6]不变；

![](https://i.loli.net/2021/05/10/lJ1fPZVH9UinK4o.png)

4）从当前剩余顶点路径中选出长度最短的，是0->1->2->5,长度为dist[5]=9,因此将顶点5并入最短路径中，set[5]置为1。

以5为中间顶点检测剩余顶点{4,6}:

* dist[4]=11>dist[5]+g[5]\[4]=10,因此dist[4]重制为10，path[4]重制为5；
* dist[6]=∞>dist[5]+g[5]\[6]=17,因此dist[6]重制为17，path[5]重制为5；

![](https://i.loli.net/2021/05/10/1DQCysMh2nuV8A4.png)

5）从通往当前剩余顶点对路径中选出长度最短的是0->1->2->4,长度为dist[4]=10,因此将顶点4并入最短路径中，set[4]重制为1，

![](https://i.loli.net/2021/05/10/siRWeHBdE1IULrS.png)

以4为中间顶点检测剩余顶点{6}:

* dist[6]=17>dist[4]+g[4]\[6]=16,因此dist[6]重制为16，path[6]重制为4；

![](https://i.loli.net/2021/05/10/LeIl9Ou6gRk4GAc.png)

6）从通往当前剩余顶点对路径中选出长度最短的，是0->1->2->5->4->6,因此将顶点6并入最短路径中，set[6]设置为1

![](https://i.loli.net/2021/05/10/IG395zwF8xDQXv1.png)

此时所有顶点都已经 并入最短路径中，求解过程结束。

得到最终的数组值见下表：

![](https://i.loli.net/2021/05/10/UVo7h38vyAfqpBJ.png)

由表可知：

* 顶点0到顶点1的最短路径为0->1，长度为4；
* 顶点0到顶点2的最短路径为0->1->2，长度为5；
* 顶点0到顶点3的最短路径为0->3，长度为6；
* 顶点0到顶点4的最短路径为0->1->2->5->4，长度为10；
* 顶点0到顶点5的最短路径为0->1->2->5，长度为9；
* 顶点0到顶点6的最短路径为0->1->2->5->4->6，长度为16；

以上是考研中的重点，考研中可能会出现手工求最短路径的题目，但过程不用像上边那么繁琐，可以根据自己理解提取要点，总结答题模版，如下：

![](https://i.loli.net/2021/05/02/2UWD6HBX3FCce7y.png)

由上表可知，从顶点0到顶点1～6，最短路径长分别为4、5、6、10、9、16。

此时path[]数组为：

![](https://i.loli.net/2021/05/02/rzKEWd8Fn6D3j7t.png)

path[]数组中其实保存类一棵树，这是一棵用双亲存储结构存储到树，通过这颗树可以打印从源点到任何一个顶点最短路径上所经过的所有顶点。

树的双亲表示法只能直接输出由叶子结点到根结点路径上的结点，不能逆向输出，因此需要借助一个栈来实现逆向输出，打印路径函数如下：

```c++
void printfPath(int path[],int a)
{
  int stack[maxSize],top=-1;
  //以叶子结点到根结点的顺序将其入栈
  while(path[a]!=-1)
  {
    stack[++top]=a;
    a=path[a];
  }
  stack[++top]=a;
  while(top!=-1)
    cout<<stack[top--]<<"";
  cout<<endl;
}
```

##### 5.2 代码实现

由上诉基本思想可以写出迪杰斯特拉算法代码：

```c++
void Dijkstra(MGraph g,int v,int dist[],int path[])
{
  int set[maxSize];
  int min,i,j,u;
  //对各个数组进行初始化
  for(i=0;i<g.n;i++)
  {
    dist[i]=g.edges[v][i];
    set[i]=0;
    if(g.edges[v][i]<INF)
      path[i]=v;
    else
      path[i]=-1;
  }
  set[v]=1;path[v]=-1;
  //初始化结束
  
  //关键操作开始
  for(i=0;i<g.n-1;++1)
  {
    min=INF;
    //循环中每次从剩余顶点中选出一个顶点，通往这个顶点的路径在通往所有顶点的路径长度是最短的
    for(j=0;j<g.n;++j)
      if(set[j]==0&&dist[j]<min)//结点未访问过且到结点的
      {
        u=j;
        min=dist[j];
      }
    set[u]=1;
    //将这个循环以刚并入顶点作为中间点，对所有剩余顶点点路径进行检测
    for(j=0;j<g.n;j++)
    {
      //判断顶点u的加入是否会出现通往顶点j顶点更短的路径，如果出现，则改变原来路径及其长度，否则什么都不做
      if(set[j]==0&&dist[u]+g.edges[u][j]<dist[j])
      {
        dist[j]=dist[u]+g.edges[u][j];
        path[j]=u;
      }
    }
  }
}
```

**算法复杂度分析**

​	由算法代码可知，本算法主要部分是一个双重循环，外层循环内有两个并列的单层循环，可以任取一个循环内的操作作为基本操作，基本操作执行总次数即为双重循环执行次数，为n<sup>2</sup>次，因此本算法时间复杂度为$O(n^2)$。

### 6.弗洛伊德算法

##### 6.1 算法基本思想

​	弗洛伊德算法是求图中**某一顶点到其余各顶点的最短路径**，如果求图中**任意一对顶点间对最短路径**，通常用弗洛伊德算法。

​	考研中涉及最多的是求用四阶方阵表示图中每两个顶点之间的最短路径过程，方阵阶阶数高会导致计算量变大，所以考试中不会涉及太多。

​	以下图为例，用弗洛伊德算法求解最短路径过程如下：

![](https://i.loli.net/2021/05/02/uAgxzfTCeo1NyDV.png)

对应的邻接矩阵如下：

<img src="https://i.loli.net/2021/05/11/ZKCqOSTRAFn9jNp.png" style="zoom: 40%;" />

​	初始时要设置两个矩阵`A`和`Path`,`A`用来记录当前已经求得的任意两个顶点的最短路径长度，`Path`用来记录当前两顶点最短路径上要经过的中间顶点。

1）初始状态为：

<img src="https://i.loli.net/2021/05/11/MR1tP8EvkwVpTcH.png" alt="截屏2021-05-11 上午8.13.09" style="zoom: 40%;" />

​	矩阵中的下表表示每一步所选的中间顶点，图的编号从0开始，初始的时候没有中间点，因此下标设为-1。

2）以0为中间点，参照上一步矩阵中的结果，检测所有顶点对：{0,1}、{0,2}、{0,3}、{1,0}、{1,2}、{1,3}、{2,0}、{2,1}、{2,3}、{3,0}、{3,1}、{3,2}，假设当前所检测的顶点对为{i,j}，如果`A[i][j]>A[i][0]+A[0][j]`,并将`Path[i][j]`改为`0`。

得到矩阵如下：

<img src="https://i.loli.net/2021/05/11/LenCwHOSfWuPQ2o.png" style="zoom:40%;" />

3)以1为中心点，参照上一步矩阵中的结果，检测所有顶点对，其中有`A[0][2]>A[0][1]+A[1][2]=5+4=9`,因此将`A[0][2]`改为9，`Path[0][2]`改为`1`。

得到修改后的矩阵如下：<img src="https://i.loli.net/2021/05/11/Ca451ESfbUjFDRs.png" style="zoom:40%;" />

4)以2为中间点，参照上一步矩阵中的结果，检测所有顶点对，其中`A[1][0]>A[1][2]+A[2][0]=4+3=7`,`A[3][1]>A[3][2]+A[2][1]=1+3=4`,因此将`A[1][0]`该为7，将`A[3][1]`改为4，将`A[3][0]`改为4，将`Path[1][0]`、`Path[3][0]`和`Path [3][1]`都改为2。

得到修改后的矩阵如下：

<img src="/Users/suneann/Library/Application Support/typora-user-images/截屏2021-05-11 上午8.15.32.png" alt="截屏2021-05-11 上午8.15.32" style="zoom:40%;" />

5）以3为中心，参照上一步矩阵中的结果，检测所有顶点对，其中`A[0][2]>A[0][3]+A[3][2]=4+3=7`,`A[1][0]>A[1][3]+A[3][0]=2+4=6`,`A[1][2]>A[1][3]+A[3][2]=2+1=3`,因此将A`[0][2]`改为8，将`A[1][0]`改为6，将`A[1][2]`改为3，将`Path[0][2]`、`Path[1][2]`都改为3。

得到矩阵如下：

<img src="https://i.loli.net/2021/05/11/bkNUdyTc2XJz1Ir.png" alt="截屏2021-05-11 上午8.16.22" style="zoom:40%;" />

因此得到最终矩阵`A`和`Path`如下：

<img src="/Users/suneann/Library/Application Support/typora-user-images/截屏2021-05-11 上午8.16.57.png" style="zoom:40%;" />

由矩阵`A`和矩阵`Path`可以算出任意两点间最短路径上的顶点序列或边序列。可按照如下步骤进行：

* 由`A[1][0]=6`可知，顶点1到顶点0存在路径上最短，则可执行下边的步骤(若`A[1][0]=∞`，则说明1到0不存在路径，路径顶点序列计算结束)；
* 由`Path[1][0]=3`可知，从顶点1到顶点0要经过顶点3，将3作为下一步起点；
* 由`Path[3][0]=2`可知，从顶点3到顶点0要经过顶点2，将2作为下一步起点；
* 由`Path[2][0]=-1`可知，从顶点2直接指向顶点0的边，求解结束。

由此从顶点1到顶点0最短路径为`1->3->2->0`。

输出两点路径实际上是一个递归过程，伪代码如下：

```c++
void printPath(int u,int v,int path[][max],int A[][max])
  //输出从u到v到最短路径上顶点序列
{
 	if(A[u][v]==INF)
    //说明无路径
   
   else
   {
     if(path[u][v]==-1)
       直接输出边<u,v>;
     else
     {
       int mid=path[u][v];
       printPath(u,mid,path);//处理mid前半段
       printPath(mid,v,path);//处理mid后半段
     }
   }
}
```

从上诉示例中可以总结出弗洛伊德算法求解最短路径一般过程如下：

* 设置两个矩阵**A**和**Path**，初始时将图邻接矩阵赋值给A，将矩阵**Path**中元素全部设置为-1。

* 以顶点k为中间顶点矩阵，k取0～n-1（n为图中的顶点个数），对图中所有顶点对{i,j}进行如下检测与修改：

  若A[i]\[j]>A[i]\[k]+A[k]\[j]，则将A[i]\[j]改为A[i]\[k]+A[k]\[j]的值，将Path[i]\[j]改为k，否则什么都不做。

##### 6.2 代码实现

​	将上述弗洛伊德算法可以写出以下代码，其中定义两个二维矩阵数组A[]\[]和Path[]\[],来保存上述矩阵A和Path。

```c++
void Floyd(MGraph*g,int Path[][maxSize],int A[][maxSize])
{
  int i,j,k;
  for(i=0;i<g->n;++i)
    for(j=0;j<g->n;++j)
    {
      A[i][j]=g->edges[i][j];
      Path[i][j]=-1;
    }
  
  //下面三层循环是算法的基本操作，完成以k为中心点对所有顶点对（i，j）进行检测和修改
  for(k=0;k<g->n;++k)
    for(i=0;i<g->n;++i)
      for(j=0;j<g->n;++j)
      	if(A[i][j]>A[i][k]+A[k][i])
        {
          A[i][i]=A[i][k]+A[k][i];
          Path[i][j]=k;
        }
}
```

**算法复杂度分析：**

​	本算法主要部分是一个三层循环，最内层循环对操作作为基本操作，则最基本操作执行次数为n<sup>3</sup>,因此时间复杂度为O(n<sup>3</sup>)。

### 7.拓扑排序

##### 7.1 AOV网

​	活动在顶点上的网（Activity On Vertex network,AOV）是一种可以形象反映整个工程中各个活动直接先后关系的有向图。

<img src="https://i.loli.net/2021/05/08/zralZ8xskAV7uRw.png" style="zoom:50%;" />

如上图，该图反映一个产品的AOV网。制造该产品需要3个环节：

* 第一个环节需要获得原材料；
* 第二个环节生产出3个部件；
* 第三个环节由3个部件组装成成品；

这样一个工程各个活动之间的先后次序关系可以用一个有向图图表示，称为AOV网。

【在考试中，只要知道AOV网上一种以顶点表示活动、以边表示活动先后次序且没有回路的有向图即可】

因为AOV网有实际意义，所以出现回路就表示一项活动可以以自己为前提，这显然是违背实际的。

##### 7.2 拓扑排序核心算法

​	对一个有向无环图G进行拓扑排序，是将G中所有顶点排成一个线性序列。若存在顶点u到v的路径，则拓扑排序序列一定是u在v的前面。

在一个有向图拓扑排序序列的过程如下：

* 从有向图中选择一个没有前驱的（入度为0）的顶点输出；
* 删除1）中的顶点，并且删除从该顶点出发的全部边；
* 重复上述两个操作，直到剩余图中不存在有前驱结点的顶点为止。

##### 7.3 拓扑排序

```c++
typedef struct
{
	char data;
  int count;	//用来统计顶点当前入度
  ArcNode *firstarc;
}VNode;
```

​	假设图的邻接表已经生成，并且各个顶点入度都已经记录在count中，这时候需要设置一个栈，用来记录当前图中入度为0的顶点，还有设置一个计数器n，用来记录已经输出的顶点个数；

​	算法开始时置n为0，扫描所有顶点，将入度为0的顶点入栈。然后在栈不空的时候循环执行：

* 出栈，将栈的顶点输出，执行++n，并且将由此顶点引出的边所指向的顶点的入度都减1，并且将入度变为0的顶点入栈；
* 出栈，...，栈空时循环退出，排序结束。
* 循环退出后判断n是否等于图中的顶点个数，如果等于则返回1，拓扑成功；否则返回0，拓扑失败。

##### 7.4 拓扑排序算法

```c++
int TopSort(AGraph *G)
{
  int i,j,n=0;
  int stack[maxSize],top=-1; //初始化堆栈
  ArcNode *p;
  
  for(i=0;i<G->n;++i)	//从图中零号结点开始编号,将入度为0的结点放入堆栈
    if(G->adjlist[i].count==0)
      stack[++top]=i;
  
  /*关键操作开始*/
  while(top!=-1)
  {
    i=stack[top--];	//顶点出栈
    ++n;
    cout<<i<<" ";	//输出当前顶点
    p->G->adjlist[i].firstarc;
    /*这个循环实现了将所有由此顶点引出的边指向的顶点入度都减少1，并将这个过程中入度变为0的顶点入栈*/
    while(p!=NULL)
    {
      j=p->adjvex;
      --(G->adjlist[j].count);
      if(G->adjlist[j].count==0)
        stack[++top]=j;
      p=p->nextarc;
    }
  }
  /*关键操作结束*/
  
  if(n==G->n)
    return 1;
  else 
    return 0;
}
```

> ​	注：拓扑排序结果可能不唯一。从算法过程中可以看出，在选择入度为0的顶点输出时，对其他顶点没有要求，只需要入度为0即可。当前步骤中有多个入度为0的顶点时，可以任选一个输出，这就造成了拓扑排序序列不唯一。

##### 7.5 逆拓扑排序

​	若AOV网考查各顶点的出度并以下列步骤进行排序，则将这种排序称为逆拓扑排序，输出的结果称为逆拓扑有序序列：

* 在网中选择一个没有后续的顶点（出度为0）输出；
* 在网中删除该顶点，并删除所有到达该顶点的边；
* 重复上述两步，直到AOV网中已无出度为0的顶点为止。

> 注意：当有向图中无环时，可以采用深度优先搜索遍历方法进行拓扑排序。由于图中无环，当由图中某顶点出发进行深度优先搜索遍历时，最先退出算法顶点即为出度为0的顶点，它是拓扑有序序列中最后一个顶点。
>
> 因此，按照DFS算法先后次序记录下的顶点序列即为逆向的拓扑有序序列。
>
> * “最先退出算法顶点即为出度为0的顶点”：所遍历的顶点退出当前系统栈；
> * “按照DFS算法的先后次序记录下的顶点序列”：按照DFS算法先后次序并不是指最终遍历结果序列，而是顶点退出系统栈的顺序；
>
> 如下面这张图：
>
> <img src="https://i.loli.net/2021/05/10/kodR1PWc9l5ryYL.png" style="zoom: 15%;" />
>
> 图{A->C,A->B,C->D,B->D}的一种深度优先遍历进出栈的过程：
>
> * A入栈（栈中元素为A）；
> * B入栈（栈为AB）；
> * D入栈（栈为ABD）；
> * D出栈（栈为AB）；
> * B出栈（栈为A）；
> * C入栈（栈为AC）；
> * C出栈（栈为A）；
> * A出栈（栈为空）；
>
> 因此各个元素出栈后序列为DBCA，为拓扑序列ACBD的逆序拓扑。

##### 7.6 例题

**【例1】**分析拓扑排序算法时间复杂度

分析：

​	算法主体部分主要分为一个单层循环和一个双重循环。

* 单层循环执行次数为n；
* 双重循环中，首先分析进栈操作，在无环情况下，每个结点恰好进栈一次，故进栈操作执行次数为n；在来分析入度减一操作，在无环情况下，排序结束后恰好每条边被逻辑删除一次，故入度减1操作执行次数为e。
* 故本算法基本操作执行次数为n+n+e，时间复杂度为O(n+e);

**【例2】**求下图所示的拓扑有序序列，要求写出求解步骤：

<img src="https://i.loli.net/2021/05/10/zYWxwkHCL49OsvU.png" style="zoom:50%;" />

解：

* 初始状态下，入度为0的顶点有0。输出0并删除其出度，得到新图；
* 由新图知，入度为0的顶点有1、3。输出1，并删除其出度，得到新图；
* 由新图知，入度为0的顶点有2、3。输出3，并删除其出度得到新图；
* 由新图知，入度为0的顶点有2。输出2，并删除其出度得到新图；
* 由新图知，入度为0的顶点有5。输出5，并删除其出度得到新图；
* 由新图知，入度为0的顶点有4。输出4，并删除其出度得到新图；
* 由新图知，入度为0的顶点有6。输出6，并删除其出度得到新图；

由以上步骤得到的拓扑序列为：0、1、3、2、5、4、6。

### 8.关键路径

​	对于活动在边上的网(AOE),可以和AOV进行对比记忆；

* 两者相同点：都是有向无环图；
* 两者不同点：AOE网的边表示活动，边有权值，边代表活动持续时间；顶点表示事件，事件是图中新活动开始或者旧活动结束的标志。
* AOV网顶点表示活动，边无权值，边代表活动之间的先后关系；
* 而对于一个工程的AOE网，只存在一个入度为0的顶点，称为**源点**，表示整个工程的开始；也只存在一个出度为0的顶点，称为**汇点**，表示工程的结束。

##### 8.1 关键路径核心算法

​	**关键路径：**在AOE网中，从源点到汇点到所有路径中，具有**最大路径长度**的路径称为关键路径。

* 完成整个工期的最短时间就是关键路径长度所代表的时间；
* 关键路径上的活动称为**关键活动**；

关键路径是一个特殊概念，它既代表了一个最短又代表了一个最长：

* 它是图中的最长路径；
* 又是整个工期所完成的最短时间；

以下图为例求它的关键路径：

<img src="https://i.loli.net/2021/05/10/cpIjBJTz8MbQfkV.png" style="zoom:50%;" />

设ve(k)为顶点k代表k的事件（以下称事件k）的最早发生时间，即从源点到顶点k到路径中的**最长者**。

为什么选择最长者呢，因为在AOE网中，若事件k要发生，必须在事件k之前的活动都已经完成的情况下才可能，k事件之前的活动是为k的发生做准备的；

由源点到k的路径不止一条，每一条都代表为事件k的发生所做的准备工作，这些准备工作是**同时开始进行的**，显然k之前的所有准备工作完成的时间，可以用其中持续时间最长的准备工作的时间来表示，因此要取从源点到顶点k的路径中最长者。

如在上图中，事件4最早发生时间的路径<0,2,4>(长度为7)所代表的时间，而不是路径<0,1,4>所代表的时间。



1）为了求出关键路径，必须求出图中每个事件的最早发生时间，具体过程如下：

* 对上图进行拓扑排序，得到各顶点的拓扑有序序列为0、1、2、3、4、5、6、7、8、9、10。
* 按照上述拓扑有序序列的顺序，依次求出各顶点所代表事件的最早发生时间。

初始时，将事件0的开始时间设置为0，即ve(0)=0。于是求得：

​		ve(1)=ve(0)+a0=0+3=3

​		ve(2)=ve(0)+a1=0+4=4

​		ve(3)=ve(1)+a0+a2=5

​		ve(4)=max{ve(1)+a3,ve(2)+a4}=max{4,7}=7

​		ve(5)=ve(2)+a5=9

​		ve(6)=max{ve(3)+a6,ve(4)+a7}=max{11,15}=15

​		ve(7)=ve(4)+a8=11

​		ve(8)=max{ve(7)+a12,ve(5)+a9}=max{21,11}=21

​		ve(9)=max{ve(7)+a11,ve(8)+a13}=max{19,22}=22

​		ve(10)=max{ve(6)+a10,ve(9)+a14}=max{22,28}=28

2）设v1(k)为事件k的最迟发生时间，事件k的最迟发生时间是在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。

* 在图图进行逆拓扑排序，得到各顶点逆拓扑有序序列为10、9、6、8、5、7、3、4、1、2、0；

* 按照上述逆拓扑有序序列的顺序，依次求出各顶点所代表事件的最迟发生时间。

  ​	vl(10)=ve(10)=28

  ​	vl(9)=vl(10)-a14=22

  ​	vl(6)=vl(10)-a10=21

  ​	vl(8)=vl(9)-a13=21

  ​	vl(5)=vl(8)-a9=19

  ​	vl(7)=min{vl(9)-a11,vl(8)-a12}=min{18,11}=11

  ​	vl(3)=vl(6)-a6=15

  ​	vl(4)=min{vl(6)-a7,vl(7)-a8}=min{15,7}=7

  ​	vl(1)=min{vl(3)-a2,vl(4)-a3}=min{13,6}=6

  ​	vl(2)=min{vl(4)-a4,vl(5)-a5}=min{4,14}=4

  ​	vl(0)=min{vl(1)-a0,vl(2)-a1}=min{3,0}=0

3）由1）、2）两步，求出图中事件最早发生时间和最迟发生时间。分别用e(ak)和l(ak)来表示当前活动ak的最早和最迟发生时间。

​	图中事件代表一个新活动的开始或旧活动的结束，因此事件最早发生时间就是由这个事件所发出的活动最早发生时间。

活动最迟发生时间怎么求得呢？由于图中事件最迟发生时间减去以它为结束点点活动持续时间，就得到活动的最迟发生时间。

①求最早发生时间

​	e(a0)=a(a1)=ve(0)=0

​	e(a2)=e(a3)=ve(1)=3

​	e(a4)=e(a5)=ve(2)=4

​	e(a6)=e(a8)=ve(4)=7

​	e(a7)=e(a8)=ve(4)=7

​	e(a9)=ve(5)=9

​	e(a10)=ve(6)=15

​	e(a11)=e(a12)=ve(7)=11

​	e(a13)=ve(8)=21

​	e(a14)=ve(9)=22

②求最迟发生时间

​	l(a0)=vl(1)-3=3

​	l(a1)=vl(2)-4=0

​	l(a2)=vl(3)-2=13

​	l(a3)=vl(4)-1=6

​	l(a4)=vl(4)-3=4

​	l(a5)=vl(5)-5=14

​	l(a6)=vl(6)-6=15

​	l(a7)=vl(6)-8=13

​	l(a8)=vl(7)-4=7

​	l(a9)=vl(8)-2=19

​	l(a10)=vl(10)-7=21

​	l(a11)=vl(9)-4=18

​	l(a12)=vl(8)-10=11

​	l(a13)=vl(9)-1=21

​	l(a14)=vl(10)-6=22

将①②两步汇总成一张表：

<img src="https://i.loli.net/2021/05/10/HljAFVY3J2MiPyx.png" style="zoom:50%;" />



表中“▲”指出来关键活动，最早发生时间和最迟发生时间相同的活动即为关键活动。

此外，还有建立一个特殊的量，叫做活动的**剩余时间**。剩余时间等于活动最迟发生时间减去活动最早发生时间，剩余时间反映了活动完成的一种**松弛度**。

由表可看出，关键活动剩余时间为0，这体现了关键活动在整个工程中的重要性，关键活动没有缓期执行的余地。

关键活动组成的关键路径由上图所示：
$$
a1+a4+a8+a12+a13+a14=28
$$
关键路径所持续的时间就是整个工程所持续的时间。



由上面过程总结求关键路径的一般方法：

* 根据图求出拓扑有序序列a和逆拓扑有序序列b；
* 根据序列a和b分别求出最早发生时间和最迟发生时间，求解方法如下：
  * 一个事件为指向它的边的权值加上发出a这条边的事件的最早发生时间，如果有多条边，则逐一求出对应的时间并选出最大的结果作为当前事件的最早发生时间；
  * 一个事件的最迟发生时间为由它所发出的边（假设为b）所指向的事件的最迟发生时间减去b这条边的权值。如果有多条边，则逐一求出对应的时间并选出对应的时间并选其中最小的结果作为当前事件的最迟发生时间。
* 根据第二条中结果求出每个活动的最早发生时间和最迟发生时间；
* 根据第三点中结果找出最早发生时间和最迟发生时间相同的活动，即为关键活动。



> 【问】一个工程的完成仅仅需要执行关键活动吗？还是说关键活动的完成的同时其他普通活动也已经完成了？
>
> 答：
>
> ​	一项工程中图中所有活动都要执行，只是关键路径执行所需时间就是整个图中所有活动所完成的时间。

























