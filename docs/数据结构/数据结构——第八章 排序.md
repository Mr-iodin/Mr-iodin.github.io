# 数据结构——第八章 排序

### 1. 排序的基本概念

##### 1.1 排序

​	所谓排序，即将原本无序的序列重新排序成有续序列过程。

* **稳定性：**指当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关系的相对位置，如果没有发生变化就是稳定，否则就是不稳定。（例如：两个关键字都是50，用50（a）和50（b）来区分，用某种算法A对其排序，排序前50(a)在50(b)之前，如果排序后50(a)仍然在50(b)之前，则A稳定；若排序后在50(a)在50(b)之后，那么A是不稳定的）。

  关键字不重复，那么排序结果唯一，那么选择排序算法稳定与否无关紧要；如果关键字可以重复，那么选择排序算法时就需要考虑选择稳定还是不稳定的算法；

* **排序算法分类：**

  * **插入类排序：**在已有序的序列中，插入一个新的关键字。如：**直接插入排序**、**折半插入排序**、**希尔排序**。
  * **交换类排序：**每一趟排序，都通过一系列的“交换”动作，让关键字排到它最终的位置上。如：**起泡排序**、**快速排序**。
  * **选择类排序：**将两个或两个以上的有序序列合并成一个新的有序序列。
  * **基数类排序：**基数类排序是基于多关键字排序的思想，把一个逻辑关键字拆分成多个关键字。

### 2. 插入类排序

##### 2.1 直接插入排序

![](https://i.loli.net/2021/05/12/czB9Memq5HwCvAT.jpg)

**代码实现：**

```c++
void InsertSort(int R[],int n)
{
  int i,j;
  int tmp;
  for(i=1;i<n;i++)
  {
    tmp=a[i];
    for(j=i-1;j>=0&&a[j]>tmp;j--)
    {
      a[j+1]=a[j];
    }
    a[j]=tmp;
  }
}
```

**算法分析：**

* 该算法共两层循环

  第一层从第二个元素向后遍历至最后一个元素；

  第二层从当前位置向前遍历直至找到最合适的插入位置。

* 时间复杂度：

  ​    考虑最坏情况，整个序列都是逆序，则循环中`a[j]>tmp`条件始终成立。此时对于每一层内层循环，基本操作总执行次数为`n(n-1)/2`，可以看出时间复杂度为`O(n^2)`；

* 空间复杂度：

  算法辅助空间不存在随待排序规模的变化而变化，是个常量，因此空间复杂度为`O(1)`。

##### 2.2 折半插入排序

![](https://i.loli.net/2021/05/12/e3ohTDSgLOfGK9P.png)

代码实现：

```c++
void BinaryInserSort(int *a,int n)
{
  for(int i=0;i<n;i++)
  {
    int temp=a[i];
    int right=0;
    while(left<=right)
    {
      int mid = (left+right)/2;
      if(a[min]>temp) right =mid-1;
      else left= mid+1;
    }
    
    for(int j=i-1;j>=left;j--)
      a[j+1]=a[j];
    a[left]=temp;
  }
}
```

**算法分析：**

* **时间复杂度分析：**

  折半插入排序适合关键字较多的场景，与直接插入排序相比，折半排序在查找插入位置上所花时间大大减少。由于关键字移动次数方面和直接排序一样，所以时间复杂度最好情况下是`O(nlog2n)`，最差情况是`O(n^2)`,平均情况为`O(n^2)`。

* **空间复杂度分析：**

  为`O(1)`。

#####  2.3.希尔排序

​	希尔排序又叫缩小增量排序。将待排序的序列按某种规则分成几个子序列，非别对这几个子序列进行直接插入排序。

​	这个规则体现的就是增量的选取，若增量为1，就是直接插入排序；若增量为5，即将下标为0、5、10、15...的关键字分成一组，将下标为1、6、11、16...分为一组，然后分别对这些组进行直接插入排序，这就是一趟希尔排序。

​	接着再以增量2分割，下标为0、2、4、6...关键字分为一组，下标为1、3、5、7...分为一组。然后进行直接插入排序。则又完成了一趟希尔排序。

​	增量按照5、2、1是逐渐缩小对，这就是缩小增量排序的由来。与直接排序进行比较，直接排序适合于序列基本有序的情况，希尔排序**每趟都会使整个序列更加有序，等整个序列基本有序的再来一趟直接排序，这样会使得排序效率更高。**

![3](https://i.loli.net/2021/05/16/dxa3qjOYEUQgc4C.jpg)

```c++
void ShellSort(int *a ,int n)
{
  int tmp,gap,k;
  for(gap=n/2;gap>0;gap/=2)
  {
    for(int i=0;i<gap;i++)
    {
      for(int j=i+gap;j<n;j+=gap)
      {
        tep=a[j];
        for(k=j-gap;k>=0&&a[k]>tmp;k-=gap)
        {
          a[k+gap]=a[gap];
        }
        a[k]=tmp;
      }
    }
  }
}
```

希尔排序是不稳定的。

**算法分析：**

* **时间复杂度分析：**希尔排序时间复杂度和增量有关，希尔排序的增量选取规则很多，在考研中增量选取规则有以下两种：

  * 希尔（Shell）自己提出的：
    $$
    \left\lfloor n/2\right\rfloor  、\left\lfloor n/4\right\rfloor 、...、\left\lfloor n/2^k\right\rfloor 、2、1
    $$
    每次讲增量除以2并向下取整，其中n为序列长度、此时时间复杂度为`O(n^2)`;

  * 帕佩尔诺夫和斯塔舍维奇提出的：
    $$
    2^k+1、...、65、33、17、9、5、3、1
    $$
    其中，k为大于等于1的整数，2<sup>k</sup>+1小于待排序列长度，增量序列末尾的1是额外添加的，此时复杂度为O(n<sup>1.5</sup>);

  > ​    希尔排序时间复杂度分析过程十分复杂，因此考研中涉及分析过程的题目只需记住上述两个常见结果即可：
  >
  > ​    希尔排序的一个考点：
  >
  > ​        请回答希尔排序增量选取时需要注意的地方：
  >
  >   答：
  >
  >         * 增量序列的最后一个值一定取1；
  >         * 增量序列中的值应尽量没有除1以外的公因子；

* **空间复杂度分析：**

  同插入排序一样为O(1);

### 3.交换类排序

##### 3.1 起泡排序

​	起泡排序又称为冒泡排序，它是通过一系列“交换”动作完成，通过比较第一和第二个关键字，若第一个较大，则两者交换，否则不交换；然后第二个关键字和第三个关键字比较，同样通过判断来决定是否进行比较......。

​	最终最大的那个关键字被交换到了最后，一趟起泡排序完成。经过多趟这样的排序，最终使得整个序列有序。

![](https://i.loli.net/2021/05/16/ndcS8kO3WwVUu7B.jpg)

```c++
void BulleSord(int *a ,int n)
{
  bool flag=FALSE;
  for(int i=0;i<N-1;i++)
  {
    for(int j=0;j<N-1-i;j++)
    {
      if(a[j]>a[j+1])
      {
        int temp;
        temp =a[j];
        a[j]=a[j+1];
        a[j+1]=temp;
        flag=TRUE;
      }
    }
    if(!flag) break;
   }
}
```

**算法分析：**

* **时间复杂度分析：**

  由起泡排序算法代码知，可选取最内层循环中的关键字交换操作作为基本操作。

  * 最坏情况下，待排序为逆序列。此时对于外层循环每次执行，内层循环中if语句的条件为`R[j]<R[j-1]`始终成立，即基本操作执行次数为n-i。i取值为`1～n-i`。因此，基本操作总执行次数为`(n-1+1)(n-1)/2=n(n-1)/2`,由此可见时间复杂度为$O(n^2)$;
  * 最好情况，待排序为有序序列，此时内层循环中if语句条件始终不成立，交换不发生，且内层循环执行n-1次后，整个算法结束，可见时间复杂度为O(n);

* **空间复杂度分析：**

  额外补助空间只有一个temp，因此空间复杂度为O(1);

##### 3.2 快速排序

​	快速排序通过多次划分操作实现排序。以升序为例，其执行流程可以概括为：每一趟选择当前子序列中的关键字（通常为第一个）作为枢轴，将子序列中比枢轴小的移到枢轴前面，比枢轴大的移到枢轴后面。当本趟所有子序列都被枢轴以上述规则划分完毕后会得到新的更短的子序列，它们成为下一趟初始序列集。

![](https://i.loli.net/2021/05/16/STLHdICiD6soFAY.jpg)

```c++
void quicksort(int *a,int l,int r)
{
  if(l<r)
  {
    int i,j,x;
    i=l;
    j=r;
    x=a[i];
    while(i<l)
    {
      while(i<j&&a[j]>x)
        j--;
      if(i<j)
        a[i++]=a[j];
      while(i<j&&a[j]<x) a[i]=1;
      	i++;
      if(i<j)
        a[j--]=a[i];
    }
    a[i]=x;
    quicksort(a,l,i-1);
    quicksort(a,i+1,r);
  }
}
```

**算法分析：**

* **时间复杂度分析：**

  ​    快速排序最好情况下时间复杂度为O(nlog<sub>2</sub>n),待排序越接近无序，本算法效率越高。最坏情况下时间复杂度为O(n<sup>2</sup>),待排序序列越接近有序，本算法效率越低。平均情况下时间复杂度为O(nlog<sub>2</sub>n)。

  快速排序的排序趟数和初始序列有关。

* **空间复杂度分析：**

  ​    本算法的空间复杂度为O(log<sub>2</sub>n)。快速排序是递归进行的，递归需要辅助栈，因此需要辅助空间比前面几类排序算法大。



### 4.选择类排序

##### 4.1 简单选择排序

​    选择排序的主要动作是“选择”，简单选择排序采用最简单的选择方式，从头至尾顺序扫描序列，找出最小的一个关键字，和第一个关键字交换，接着从剩下关键字中继续这种选择和交换，最终使序列有序。

![](https://i.loli.net/2021/05/16/H13s7zPYyhvtAq6.jpg) 

```c++
void SelectSort(int *a,int n)
{
  for(int i=0;i<n-1;i++)
  {
    int min = i;
    for(int j=i+1;j<n;j++)
      if(a[j]<a[min])
        min=j;
    int temp;
    temp=a[i];a[i]=a[j];a[j]=temp;
  }
}
```

**算法分析：**

* **时间复杂度分析：**

  ​    通过本算法代码可以看出，两层循环执行次数和初始序列没有关系，外层循环执行n次，内层循环执行n-1次，将最内层循环中的比较操作视为关键操作，其执行次数为`(n-1+1)(n-1)/2=n(n-1)/2`,即时间复杂度为O(n<sup>2</sup>)。

* **空间复杂度分析：**

  空间复杂度为O(1)。

##### 4.2 堆排序

​	堆是一组数据结构，可以把堆看成一棵完全二叉树，这颗完全二叉树满足：任何一个非叶结点的值都不大于（或不小于）其左孩子结点的值。若父亲大孩子小，则这样的堆叫作大顶堆；若父亲小孩子大，这样的堆叫作小顶堆。

​	根据堆堆定义知，代表堆堆这颗完全二叉树的根结点的值是最大（或最小）的，因此将一个无序序列调整为一个堆，就可以找出这个序列的最大（或最小）值，然后将找出的这个值交换到序列的最后（或最前），这样，有序序列关键字增加1个，无序序列的关键字减少1个，对新的无序序列重复这样的操作，就实现了排序。

![](https://i.loli.net/2021/05/16/1Q5KnXZC8JeyGB4.jpg)

**算法分析：**

* **时间复杂度分析：**

  ​    整个算法基本操作的次数为$O(log_2n)\times n/2+O(log_2n)\times (n-1)$,化简后其时间复杂度为$O(nlog_2n)$。

* **空间复杂度分析：**

  ​    空间复杂度为O(1);

##### 4.3 二路归并排序

**算法流程：**

原始序列：49、38、65、97、76、13、27。

1）将原始序列看成7个只含有一个关键字的子序列，显然子序列都是有序的。

子序列1：49；

子序列2：38；

子序列3：65；

子序列4：97；

子序列5：76；

子序列6：13；

子序列7：27；

2）两两归并，形成若干有序二元组，即49和38归并{38 49},65和97归并{65 97},76和13归并{13 76},27没有归并对象，保持原样。得到第一趟归并结果如下：

<center>{38 49}、{65 97}、{13 76}、{27}</center>

3)再将这个序列看成若干有序二元组：

​		子序列1：{38 49}；

​		子序列2：{65 97}；

​		子序列3：{13 76}；

​		子序列4：{27}；

 4)继续两两归并，形成若干有序四元组。即{38 49}和{65 97}归并成{38 49 65 97};{13 76}和{27}归并形成{13 27 76};得到第二趟归并排序的结果如下：

​		子序列1：{38 49 65 97};

​		子序列2：{13 27 76}；

5)最后，只有两个子序列，最终再进行一次排序就完成整个二路排序：

<center>{13 27 38 49 65 76 97}</center>

**代码实现：**

```c++
void merge(int a[],int l,int r,int mid)
{
  int aux[r-l+1],i,j,k;
  
  for(k=l;k<=r;k++)
  aux[k-l]=a[k];
  i=l;
  j=mid+1;
  for(k=l;k<=r;k++)
  {
      if(i>mid)
      {
        a[k]=aux[j-l];
        j++;
      }
      else if(j>r)
      {
        a[k]=aux[i-l];
        i++;
      }
      else if(aux[i-l]>aux[j-l])
      {
        a[k]=aux[j-l];
        j++;
       }
      else
      {
        a[k]=aux[i-l];
        i++;
      }
	 }	
}
void merge_sort(int a[],int l,int r)
{
  if(l>=r)
	return ;
	
	int mid=(l+r)/2;
	
	merge_sort(a,l,mid);//归并排序前半段
	merge_sort(a,mid+1,r);//归并排序后半段
	merge(a,l,r,mid);	//把两段有序数组归并成一段有序序列
	
}
void mergesort(int a[],int l,int r)
{
	merge_sort(a,l,r-1);
}
```

**算法分析：**

* **时间复杂度分析：**归并排序可取函数`merge()`内的“归并操作”作为基本操作。在顺序表中，函数`merge()`的“归并操作”执行次数为要归并的两个子序列中关键字个数之和，由整个排序过程可知：

  * **第1趟**：需要执行`2×(n/2)=n`次基本操作；
  * **第2趟**：需要执行`4×(n/4)=n`次基本操作；
  * **第3趟**：需要执行`8×(n/8)=n`次基本操作；
  * ...
  * **第n趟**：需要执行$2^k×(n/2^k)=n$次基本操作；

  当$n/2^2=1$时，即需要归并两个子序列长度均为原序列的一半。因此整个归并排序中总基本操作执行次数为$nlog_2n$，时间复杂度为$O(nlog_2n)$。

* **空间复杂度分析：**

  空间复杂度为$O(n)$。



