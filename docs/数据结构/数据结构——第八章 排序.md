# 数据结构——第八章 排序

### 1. 排序的基本概念

##### 1.1 排序

​	所谓排序，即将原本无序的序列重新排序成有续序列过程。

* **稳定性：**指当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关系的相对位置，如果没有发生变化就是稳定，否则就是不稳定。（例如：两个关键字都是50，用50（a）和50（b）来区分，用某种算法A对其排序，排序前50(a)在50(b)之前，如果排序后50(a)仍然在50(b)之前，则A稳定；若排序后在50(a)在50(b)之后，那么A是不稳定的）。

  关键字不重复，那么排序结果唯一，那么选择排序算法稳定与否无关紧要；如果关键字可以重复，那么选择排序算法时就需要考虑选择稳定还是不稳定的算法；

* **排序算法分类：**

  * **插入类排序：**在已有序的序列中，插入一个新的关键字。如：**直接插入排序**、**折半插入排序**、**希尔排序**。
  * **交换类排序：**每一趟排序，都通过一系列的“交换”动作，让关键字排到它最终的位置上。如：**起泡排序**、**快速排序**。
  * **选择类排序：**将两个或两个以上的有序序列合并成一个新的有序序列。
  * **基数类排序：**基数类排序是基于多关键字排序的思想，把一个逻辑关键字拆分成多个关键字。

### 2. 插入类排序

##### 2.1 直接插入排序

![](https://i.loli.net/2021/05/12/czB9Memq5HwCvAT.jpg)

**代码实现：**

```c++
void InsertSort(int R[],int n)
{
  int i,j;
  int tmp;
  for(i=1;i<n;i++)
  {
    tmp=a[i];
    for(j=i-1;j>=0&&a[j]>tmp;j--)
    {
      a[j+1]=a[j];
    }
    a[j]=tmp;
  }
}
```

**算法分析：**

* 该算法共两层循环

  第一层从第二个元素向后遍历至最后一个元素；

  第二层从当前位置向前遍历直至找到最合适的插入位置。

* 时间复杂度：

  ​    考虑最坏情况，整个序列都是逆序，则循环中`a[j]>tmp`条件始终成立。此时对于每一层内层循环，基本操作总执行次数为`n(n-1)/2`，可以看出时间复杂度为`O(n^2)`；

* 空间复杂度：

  算法辅助空间不存在随待排序规模的变化而变化，是个常量，因此空间复杂度为`O(1)`。

##### 2.2 折半插入排序

![](https://i.loli.net/2021/05/12/e3ohTDSgLOfGK9P.png)

代码实现：

```c++
void BinaryInserSort(int *a,int n)
{
  for(int i=0;i<n;i++)
  {
    int temp=a[i];
    int right=0;
    while(left<=right)
    {
      int mid = (left+right)/2;
      if(a[min]>temp) right =mid-1;
      else left= mid+1;
    }
    
    for(int j=i-1;j>=left;j--)
      a[j+1]=a[j];
    a[left]=temp;
  }
}
```

**算法分析：**

* **时间复杂度分析：**

  折半插入排序适合关键字较多的场景，与直接插入排序相比，折半排序在查找插入位置上所花时间大大减少。由于关键字移动次数方面和直接排序一样，所以时间复杂度最好情况下是`O(nlog2n)`，最差情况是`O(n^2)`,平均情况为`O(n^2)`。

* **空间复杂度分析：**

  为`O(1)`。

#####  2.3.希尔排序

​	希尔排序又叫缩小增量排序。将待排序的序列按某种规则分成几个子序列，非别对这几个子序列进行直接插入排序。

​	这个规则体现的就是增量的选取，若增量为1，就是直接插入排序；若增量为5，即将下标为0、5、10、15...的关键字分成一组，将下标为1、6、11、16...分为一组，然后分别对这些组进行直接插入排序，这就是一趟希尔排序。

​	接着再以增量2分割，下标为0、2、4、6...关键字分为一组，下标为1、3、5、7...分为一组。然后进行直接插入排序。则又完成了一趟希尔排序。

​	增量按照5、2、1是逐渐缩小对，这就是缩小增量排序的由来。与直接排序进行比较，直接排序适合于序列基本有序的情况，希尔排序**每趟都会使整个序列更加有序，等整个序列基本有序的再来一趟直接排序，这样会使得排序效率更高。**

![3](https://i.loli.net/2021/05/16/dxa3qjOYEUQgc4C.jpg)

```c++
void ShellSort(int *a ,int n)
{
  int tmp,gap,k;
  for(gap=n/2;gap>0;gap/=2)
  {
    for(int i=0;i<gap;i++)
    {
      for(int j=i+gap;j<n;j+=gap)
      {
        tep=a[j];
        for(k=j-gap;k>=0&&a[k]>tmp;k-=gap)
        {
          a[k+gap]=a[gap];
        }
        a[k]=tmp;
      }
    }
  }
}
```

希尔排序是不稳定的。

**算法分析：**

* **时间复杂度分析：**希尔排序时间复杂度和增量有关，希尔排序的增量选取规则很多，在考研中增量选取规则有以下两种：

  * 希尔（Shell）自己提出的：
    $$
    \left\lfloor n/2\right\rfloor  、\left\lfloor n/4\right\rfloor 、...、\left\lfloor n/2^k\right\rfloor 、2、1
    $$
    每次讲增量除以2并向下取整，其中n为序列长度、此时时间复杂度为`O(n^2)`;

  * 帕佩尔诺夫和斯塔舍维奇提出的：
    $$
    2^k+1、...、65、33、17、9、5、3、1
    $$
    其中，k为大于等于1的整数，2<sup>k</sup>+1小于待排序列长度，增量序列末尾的1是额外添加的，此时复杂度为O(n<sup>1.5</sup>);

  > ​    希尔排序时间复杂度分析过程十分复杂，因此考研中涉及分析过程的题目只需记住上述两个常见结果即可：
  >
  > ​    希尔排序的一个考点：
  >
  > ​        请回答希尔排序增量选取时需要注意的地方：
  >
  >   答：
  >
  >         * 增量序列的最后一个值一定取1；
  >         * 增量序列中的值应尽量没有除1以外的公因子；

* **空间复杂度分析：**

  同插入排序一样为O(1);

### 3.交换类排序

##### 3.1 起泡排序

​	起泡排序又称为冒泡排序，它是通过一系列“交换”动作完成，通过比较第一和第二个关键字，若第一个较大，则两者交换，否则不交换；然后第二个关键字和第三个关键字比较，同样通过判断来决定是否进行比较......。

​	最终最大的那个关键字被交换到了最后，一趟起泡排序完成。经过多趟这样的排序，最终使得整个序列有序。

![](https://i.loli.net/2021/05/16/ndcS8kO3WwVUu7B.jpg)

```c++
void BulleSord(int *a ,int n)
{
  bool flag=FALSE;
  for(int i=0;i<N-1;i++)
  {
    for(int j=0;j<N-1-i;j++)
    {
      if(a[j]>a[j+1])
      {
        int temp;
        temp =a[j];
        a[j]=a[j+1];
        a[j+1]=temp;
        flag=TRUE;
      }
    }
    if(!flag) break;
   }
}
```

**算法分析：**

* **时间复杂度分析：**

  由起泡排序算法代码知，可选取最内层循环中的关键字交换操作作为基本操作。

  * 最坏情况下，待排序为逆序列。此时对于外层循环每次执行，内层循环中if语句的条件为`R[j]<R[j-1]`始终成立，即基本操作执行次数为n-i。i取值为`1～n-i`。因此，基本操作总执行次数为`(n-1+1)(n-1)/2=n(n-1)/2`,由此可见时间复杂度为$O(n^2)$;
  * 最好情况，待排序为有序序列，此时内层循环中if语句条件始终不成立，交换不发生，且内层循环执行n-1次后，整个算法结束，可见时间复杂度为O(n);

* **空间复杂度分析：**

  额外补助空间只有一个temp，因此空间复杂度为O(1);

##### 3.2 快速排序

​	快速排序通过多次划分操作实现排序。以升序为例，其执行流程可以概括为：每一趟选择当前子序列中的关键字（通常为第一个）作为枢轴，将子序列中比枢轴小的移到枢轴前面，比枢轴大的移到枢轴后面。当本趟所有子序列都被枢轴以上述规则划分完毕后会得到新的更短的子序列，它们成为下一趟初始序列集。

![](https://i.loli.net/2021/05/16/STLHdICiD6soFAY.jpg)

```c++
void quicksort(int *a,int l,int r)
{
  if(l<r)
  {
    int i,j,x;
    i=l;
    j=r;
    x=a[i];
    while(i<l)
    {
      while(i<j&&a[j]>x)
        j--;
      if(i<j)
        a[i++]=a[j];
      while(i<j&&a[j]<x) a[i]=1;
      	i++;
      if(i<j)
        a[j--]=a[i];
    }
    a[i]=x;
    quicksort(a,l,i-1);
    quicksort(a,i+1,r);
  }
}
```

**算法分析：**

* **时间复杂度分析：**

  ​    快速排序最好情况下时间复杂度为O(nlog<sub>2</sub>n),待排序越接近无序，本算法效率越高。最坏情况下时间复杂度为O(n<sup>2</sup>),待排序序列越接近有序，本算法效率越低。平均情况下时间复杂度为O(nlog<sub>2</sub>n)。

  快速排序的排序趟数和初始序列有关。

* **空间复杂度分析：**

  ​    本算法的空间复杂度为O(log<sub>2</sub>n)。快速排序是递归进行的，递归需要辅助栈，因此需要辅助空间比前面几类排序算法大。



### 4.选择类排序

##### 4.1 简单选择排序

​    选择排序的主要动作是“选择”，简单选择排序采用最简单的选择方式，从头至尾顺序扫描序列，找出最小的一个关键字，和第一个关键字交换，接着从剩下关键字中继续这种选择和交换，最终使序列有序。

![](https://i.loli.net/2021/05/16/H13s7zPYyhvtAq6.jpg) 

```c++
void SelectSort(int *a,int n)
{
  for(int i=0;i<n-1;i++)
  {
    int min = i;
    for(int j=i+1;j<n;j++)
      if(a[j]<a[min])
        min=j;
    int temp;
    temp=a[i];a[i]=a[j];a[j]=temp;
  }
}
```

**算法分析：**

* **时间复杂度分析：**

  ​    通过本算法代码可以看出，两层循环执行次数和初始序列没有关系，外层循环执行n次，内层循环执行n-1次，将最内层循环中的比较操作视为关键操作，其执行次数为`(n-1+1)(n-1)/2=n(n-1)/2`,即时间复杂度为O(n<sup>2</sup>)。

* **空间复杂度分析：**

  空间复杂度为O(1)。

##### 4.2 堆排序

​	堆是一组数据结构，可以把堆看成一棵完全二叉树，这颗完全二叉树满足：任何一个非叶结点的值都不大于（或不小于）其左孩子结点的值。若父亲大孩子小，则这样的堆叫作大顶堆；若父亲小孩子大，这样的堆叫作小顶堆。

​	根据堆堆定义知，代表堆堆这颗完全二叉树的根结点的值是最大（或最小）的，因此将一个无序序列调整为一个堆，就可以找出这个序列的最大（或最小）值，然后将找出的这个值交换到序列的最后（或最前），这样，有序序列关键字增加1个，无序序列的关键字减少1个，对新的无序序列重复这样的操作，就实现了排序。

![](https://i.loli.net/2021/05/16/1Q5KnXZC8JeyGB4.jpg)

**算法分析：**

* **时间复杂度分析：**

  ​    整个算法基本操作的次数为$O(log_2n)\times n/2+O(log_2n)\times (n-1)$,化简后其时间复杂度为$O(nlog_2n)$。

* **空间复杂度分析：**

  ​    空间复杂度为O(1);

##### 4.3 二路归并排序

**算法流程：**

原始序列：49、38、65、97、76、13、27。

1）将原始序列看成7个只含有一个关键字的子序列，显然子序列都是有序的。

子序列1：49；

子序列2：38；

子序列3：65；

子序列4：97；

子序列5：76；

子序列6：13；

子序列7：27；

2）两两归并，形成若干有序二元组，即49和38归并{38 49},65和97归并{65 97},76和13归并{13 76},27没有归并对象，保持原样。得到第一趟归并结果如下：

<center>{38 49}、{65 97}、{13 76}、{27}</center>

3)再将这个序列看成若干有序二元组：

​		子序列1：{38 49}；

​		子序列2：{65 97}；

​		子序列3：{13 76}；

​		子序列4：{27}；

 4)继续两两归并，形成若干有序四元组。即{38 49}和{65 97}归并成{38 49 65 97};{13 76}和{27}归并形成{13 27 76};得到第二趟归并排序的结果如下：

​		子序列1：{38 49 65 97};

​		子序列2：{13 27 76}；

5)最后，只有两个子序列，最终再进行一次排序就完成整个二路排序：

<center>{13 27 38 49 65 76 97}</center>

**代码实现：**

```c++
void merge(int a[],int l,int r,int mid)
{
  int aux[r-l+1],i,j,k;
  
  for(k=l;k<=r;k++)
  aux[k-l]=a[k];
  i=l;
  j=mid+1;
  for(k=l;k<=r;k++)
  {
      if(i>mid)
      {
        a[k]=aux[j-l];
        j++;
      }
      else if(j>r)
      {
        a[k]=aux[i-l];
        i++;
      }
      else if(aux[i-l]>aux[j-l])
      {
        a[k]=aux[j-l];
        j++;
       }
      else
      {
        a[k]=aux[i-l];
        i++;
      }
	 }	
}
void merge_sort(int a[],int l,int r)
{
  if(l>=r)
	return ;
	
	int mid=(l+r)/2;
	
	merge_sort(a,l,mid);//归并排序前半段
	merge_sort(a,mid+1,r);//归并排序后半段
	merge(a,l,r,mid);	//把两段有序数组归并成一段有序序列
	
}
void mergesort(int a[],int l,int r)
{
	merge_sort(a,l,r-1);
}
```

**算法分析：**

* **时间复杂度分析：**归并排序可取函数`merge()`内的“归并操作”作为基本操作。在顺序表中，函数`merge()`的“归并操作”执行次数为要归并的两个子序列中关键字个数之和，由整个排序过程可知：

  * **第1趟**：需要执行`2×(n/2)=n`次基本操作；
  * **第2趟**：需要执行`4×(n/4)=n`次基本操作；
  * **第3趟**：需要执行`8×(n/8)=n`次基本操作；
  * ...
  * **第n趟**：需要执行$2^k×(n/2^k)=n$次基本操作；

  当$n/2^2=1$时，即需要归并两个子序列长度均为原序列的一半。因此整个归并排序中总基本操作执行次数为$nlog_2n$，时间复杂度为$O(nlog_2n)$。

* **空间复杂度分析：**

  空间复杂度为$O(n)$。

##### 4.4 基数排序

**基本概念**

​	基数排序的思想是“**多关键字排序**”。基数排序有两种实现方式：

* **最高位优先**：按最高位排成若干子序列，再对每个子序列按次高位排序；
* **最低位优先**：这种方式不必分成子序列，每次排序全体关键字都参与。最低位可以优先这样进行，不通过比较，而是通过“分配”和“收集”。

**算法流程**

​	初始桶如图所示

![](https://i.loli.net/2021/05/18/pwXGstSuZf7inBE.png)

初始序列为：**278 109 063 930 589 184 505 269 008 083**

每个关键字的每一位是由“数字”组成的，数字的范围0～9，所以准备10个桶来放关键字。（要注意的是，组成关键字的每一位不一定是数字。）

（1）进行第一趟分配和收集，要按照最后一位。

​			①分配过程如下

​					278的最低是8，放到桶8中。![](https://i.loli.net/2021/05/18/J65OhXMLUsgoHA8.png)

​					109的最低位是9，放到桶9中。

![](https://i.loli.net/2021/05/18/rT2m8S7wYj3ZRNE.png)

​					按照这样的方法，依次（按原始序列顺序）将原始序列的每个数放到对应的桶中。第一趟分配过程如下

![](https://i.loli.net/2021/05/18/qVjkup3gsTC27G1.png)

​			②收集过程是这样：按桶0到桶9的顺序收集，注意关键字从桶下面出。

​					桶0：930；

​					桶1：没关键字，不收集；

​					桶2：没关键字，不收集；

​					桶3：063，083；

​									...

​					桶8：278，008；

​					桶9：109，589，269；

将每桶收集的关键字依次排开，所以第一趟收集后的结果为：

<center>930、063、083、184、505、278、008、109、589、269</center>

注意观察，最低位有序了，这就是第一趟基数排序后的结果。

（2）在第一趟排序结果的基础上，进行第二趟分配和收集，这次按照中间位。

​			①第二趟分配过程如下。

​					930的中间位是3，放到桶3中。

![](https://i.loli.net/2021/05/18/HVhEaNeTlsin3UY.png)

​					 063的中间位是6，放桶6中。

![](https://i.loli.net/2021/05/18/FCgebEUQfNd3l4L.png)

​					 按照同样的方法，将其余关键字依次入桶。

![](https://i.loli.net/2021/05/18/y5qmzcORLTQ4hen.png)

​			②进行第二趟收集

​					桶0：505、008、109；

​					桶1：没关键字，不收集；

​					桶2：没关键字，不收集；

​					桶3：930；

​									...

​					桶8：083、184、589；

​					桶9：没关键字，不收集；

第二趟收集结果为：

<center>505、008、109、930、063、269、278、083、184、589</center>

​	此时中间位有序了，并且中间位相同的那些关键字，其最低位也是有序的，第二趟基数排序结束。

（2）在第二趟排序结果的基础上，进行第三趟分配和收集，这次按照最高位。

​			①第三趟分配过程如下。

​					505的最高位是5，放到桶5中；

![](https://i.loli.net/2021/05/18/YAeEVvOozW3KSZ6.png)

​					008最高位是0，放到桶0中；			![](https://i.loli.net/2021/05/18/zcEPBYLkt5ox4Wu.png)

​			按同样的方法，将其余关键字依次入桶，结果如下：

![](https://i.loli.net/2021/05/18/3hmB1xySOJiNp8a.png)

​				②第三趟收集结果为：

<center>008、063、083、109、184、269、178、505、589、930</center>

​	于是整个序列有序，基数排序过程结束。

**算法分析：**

* **时间复杂度分析：**平均和最坏情况下都是$O(d(n+r_d))$;
* **空间复杂度分析：**$O(r_d)$;

​        基数排序适合场景是序列中关键字很多，但组成关键字取值范围很小，如数字0～9是可以接受的。如果关键字取值范围很大，如26个字母，并且序列中大多数关键字的最高位关键字都不相同，那么这时可以考虑使用“最高位优先法”，先根据最高位排成若干子序列，然后分别对这些子序列进行直接插入排序。

### 5 外部排序

外部排序是**选择排序**的一种。

**基本概念**

​	外部排序即对**外存中的记录进行排序**（相对于内部排序而言）。概括为一句话：**将内存作为工作空间来辅助外存数据的排序。**

**算法流程**

​	外部排序最常用的算法是**归并排序**。因为归并排序不需要将全部记录都读入内存即可完成排序，这可以解决由于内存空间不足导致的无法对大规模记录排序问题。

​	假设要对外存中的一组大规模无序记录进行归并排序，可按照如下步骤：

​	①将这组记录假设为n个，分为m个规模较小的记录段（记录段长度不一定相等），并对这些小段记录段哦排序。一般情况下记录段都足够小，可以整段度入内存并选择合适的排序算法对其排序。

​	②将这m个有序记录段每k段分为一组，得到$\left\lceil m/k\right\rceil  $组记录段。取其中一组（如下图），每行一段，将每段段首段记录读入内存中，如灰色部分，

<img src="https://i.loli.net/2021/05/18/OZtCPFYVAc9T6iX.png" style="zoom: 67%;" />

​	③用某种算法从读入内存的这组记录中选出最小的，如图

<img src="https://i.loli.net/2021/05/18/t1zQYaP5gWjqx9i.png" style="zoom:67%;" />

​	④将上一步中选出最小值写回外存，并将其所在记录段的次小值读入内存以补上空位置

<img src="https://i.loli.net/2021/05/18/7CGD2o1ydhwRcTU.png" style="zoom:67%;" />

​	⑤重复上述过程

<img src="https://i.loli.net/2021/05/18/fKRYW5pxiBq24Vc.png" style="zoom:67%;" />

​	⑥当此组记录全部导出后，就会在外存中得到一个较长的有序记录。整个过程只用了k个内存空间，达到了用较小的内存空间完成较大规模记录排序的目的。

（上边算法称为k路归并排序算法，如果k等于2，就是我们熟悉的二路归并排序算法的外存版）

**重要子算法**

* **置换-选择排序**：上边步骤①中的m个有序记录段称为**初始归并段**。如果被划分的每个小记录段规模不够小，依然无法完全读入内存，则无法用内排序得到初始归并段，因此需要一种适用于初始归并段规模的、高效的且不受内存空间限制的排序算法，即**置换-选择排序**；
* **最佳归并树**：将当前m组（每组含有k个有序记录段）记录归并为m个有序记录段的过程称为一趟归并，可见每个记录在每趟归并中需要两次I/O操作（读写操作各一次）。读写操作是非常耗时的，可见减少归并次数可以提高效率。为了使得归并次数最少，需要用到**最佳归并树**；
* **败者树**：归并算法中有一个多次出现的步骤，就是从当前k个值中用某种算法选出最值，可见提高最值的效率也是整个归并排序算法中的关键，这就需要用到败者树。
